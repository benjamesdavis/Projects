<html>

<head>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Caveat">
    <style>
      /*CSS Styling*/
      .line {
      stroke-width: 1px;
      stroke: grey;
      fill: none
      }
      .mean {
      stroke-width: 1px;
      stroke: black;
      }
      .canvas {
      display:flex;
      flex-direction: column;
      }
      .subdiv {
      display:flex;
      flex-direction: row;
      }
      .bottomContainer {
      display:flex;
      flex-direction: column;
      }
      .over {
      fill: url(#gradient)
      }
      .under {
      fill: #233240
      }
      #histo-container {
      margin-left: 10px;
      }

      h1, h2, h3, h4, h5, h6 {
        font-family: "Bitter";
        fill: #2c3e50;
      }
      .lab-text {
        fill: #78909c;
        font-size: 13px;
        font-family: "Bitter"
      }
      .num-text {
        fill: #78909c;
        font-family: "Bitter"
      }
      #lineChartCont {
        background: #F7F8F9;
        border: 1px solid #d9d9db;
        border-radius: 10px;
        position: relative;
      }
      .annotation-note-label {
        fill: #78909c;
        font-size: 13px;
        font-family: "Bitter"
      }
      .subject,.note-line,.connector {
        stroke: white;
        stroke-width: 1.2px;
      }
      #mainView {
        padding-top: 20px;
        padding-left: 20px;
      }
      #topView {
        padding-bottom: 20px;
      }
      #title {
        color: #2c3e50;
        font-size: 23px;
        font-family: "Bitter";
        padding-bottom: 10px;
      }
      #AnnWindow, #pageNum{
        font-family: "Caveat";
        font-size: 22px;
      }
      @keyframes fadein {
        from { opacity: 0; }
        to   { opacity: 1; }
      }
      #hG {
        font-size: 20px;
        animation: fadein 3s;
      }
      .histo-lab {
        fill: #9d9d9d;
        font-family: "Bitter";
        font-size: 13px;
        letter-spacing: 1.5px;
        transform: rotate(90deg);
      }
      #histo-container {
        border: 0px;
        border-radius: 10px;
      }
      .histoBackground {
        fill: url(#histoGrad);
      }
      #annCont {
        margin-left: 20px;
        height: 250px;
        width: 400px;
        background: no-repeat left/100% 100% url('Paper.PNG');
        position: relative;
        min-width: 400px;
      }
      @keyframes glowing {
        0% { fill: #dadada;  }
        50% { fill: #ababac;  }
        100% { fill: #dadada; }
      }
      #nextButton {
        position: absolute;
        bottom: 6px; right: 5px;
      }
      .nextButton-ready {
        animation: glowing 1500ms infinite  !important;
      }
      .nextButton-waiting {
        fill: #dadada;
      }
      .noClick{
        pointer-events: none;
      }
      #nextText {
        transform-origin: right top;
        transform: rotate(315deg);
        font-family: "Caveat";
        font-size: 20px;
        fill: white;
        user-select: none;
      }
      #toggleBars {
        position: absolute; right:5; top:5;
      }
      #callout {
        font-family: "Caveat";
        font-size: 20px;
      }
      .shuffle-button {
        background: linear-gradient(to left, rgba(0,0,0,0) 50%, rgba(230, 242, 255,1) 50%);
        background-size: 200% 100%;
        background-position:right bottom;
        transition:all 0.4s ease;
      }
      .shuffle-button:hover {
        background-position:left bottom;
      }
      .shuffle-button:active {
        background: linear-gradient(to left, rgba(92,108,124,1)  50%, rgba(92,108,124,1) 50%)
      }
      .shuffle-text {
        user-select: none;
        font-family: "Caveat";
        font-size: 20px;
      }
      .shuffle-button:active > .shuffle-text{
        fill: white;
      }
      #pageNum {
        position: absolute;
        top: 5px; right: 9px;
      }
      #annWindow {
        position: absolute;
        top: 32px; left: 55px;
      }
      #buttonG {
        position: absolute;
        top: 40%; left: 20%;
      }
      #autoButton {
        margin-left: 20px
      }
      #resetButton {
        position: absolute;
        top:2%; right:2%;
        border-radius: 50%;
        border: 1px solid rgba(0,0,0,0.1);
      }
      #arrow {
        transform-origin: 20px 55px;
        transform: rotate(40deg);
        offset-path:path('M27,30');
        pointer-events: none;
      }
      #circle {
        pointer-events: none;
      }

      @keyframes move {
        100% {offset-distance: 100%;}
      }
      #resetButton:hover #arrow{
        transform-origin: 20px 55px;
        transform: rotate(-85deg);
        offset-path: path('M20 50, A30 30, 0, 0 0, 80 50, A30 30, 0, 0 0, 27 30');
        animation: move 1.2s linear forwards;
      }
      #resetButton:active {
        background-color: darkgrey;
      }
      #resetButton:active #circle{
        stroke: white;
      }
      #resetButton:active #arrow{
        fill: white;
      }
      #firstSimAnn {
        white-space: pre;
      }

      #mainView {
        position: relative;
      }
      #sketchyBox {
        position: absolute;
      }





    </style>

  <!-- Load d3 -->
  <script src="https://d3js.org/d3.v5.min.js"></script>

  <!-- Load bootstrap -->
  <script src="http://code.jquery.com/jquery.js"></script>
  <link href="../bootstrap-4.4.1-dist/css/bootstrap.min.css" rel="stylesheet" media="screen">
  <script src="../bootstrap-4.4.1-dist/js/bootstrap.min.js"></script>

  <!-- Load d3-annotation -->
  <script src="https://rawgit.com/susielu/d3-annotation/master/d3-annotation.min.js"></script>

</head>


<body>

<!--<div class="btn-group" role="group" aria-label="Basic example">
	<button type="button" class="btn btn-primary" id="shuffleBatch" >start</button>
</div>-->
  <div id="mainView" class = "canvas">
      <div id="title">An Intro to ChangePoint Analysis</div>
      <div id="topView" class = "subdiv">
        <div id="lineChartCont" class = "canvas"></div>
        <div id="annCont"></div>
      <!--  <div class="button"><button id="showBars" type="button">Toggle Bars</button></div>-->
      </div>
      <div class = "bottomContainer">
        <h5>Simulation statistics</h5>
        <div id="bottomView" class = "subdiv">
          <div id="cusumView"></div>
          <div id="histoView" class = "subdiv">
            <div id="histoChart"></div>
            <div id="histoLab"></div>
          </div>
        </div>
      </div>
  </div>
  </div>
</body>



<script>

w = 400
h = 250

let lineMargin = {top: 45, right: 0, bottom: 30, left: 0};
let lineWidth = w - lineMargin.left - lineMargin.right,
    lineHeight = h - lineMargin.top - lineMargin.bottom;

let svg = d3.select("#lineChartCont").append("svg").attr("id","lineChart")
  .attr("transform", "translate("+lineMargin.left+", "+lineMargin.top+")")
  .attr("width", w)
  .attr("height", h-lineMargin.top-lineMargin.bottom)

//let cardSvg = d3.select("#annCont").append("svg").attr("width",w).attr("height",h).attr("id","cardSvg")
annCont = d3.select("#annCont")

let AnnWindow= annCont.append("svg").attr("id","AnnWindow").attr("width",320).attr("height",200)
  //.attr("width","auto").attr("height","auto")

//cardSvg.append("svg").attr("id","test").attr("x",50).attr("y",50)
let PageNum = annCont.append("svg").attr("id","pageNum")
  .attr("width",30)
  .attr("height",30)
  .append("g").attr("transform","translate(0,0)")

PageNum.append("svg:image")
  .attr("width","100%")
  .attr("height","100%")
  .attr("xlink:href", "penCircle.png")


let nextButtonSize = 38
let nextButton = annCont
  .append("svg")
  .attr("id","nextButton")
  .attr("width",nextButtonSize)
  .attr("height",nextButtonSize)
  .attr("x",357)
  .attr("y",h-44)


let cusumSvg = d3.select("#cusumView").append("svg").attr("id","cusumSvg").attr("width", w*2).attr("height", h).style("border-style", "solid").style("border-width", "0px").style("border-radius", "10px").style("background-color", "#2c3e50")
var gradient = svg.append("linearGradient").attr("id","gradient").attr("x1","0").attr("x2","0").attr("y1","0").attr("y2","1")
  gradient.append('stop').attr('stop-color', d3.rgb("#78909c")).attr('offset', '0%');
  gradient.append('stop').attr('stop-color', d3.rgb("#4e616e")).attr('offset', '33%');
  gradient.append('stop').attr('stop-color', d3.rgb("#233240")).attr('offset', '95%');

histoWidth = 125
let histoSVG = d3.select("#histoChart").append("svg").attr("id","histo-container").attr("width",histoWidth).attr("height",h)
let histoBackground = histoSVG.append("rect").attr("class","histoBackground").attr("width",histoWidth).attr("height",h)
var histoGradient = histoSVG.append("linearGradient").attr("id","histoGrad").attr("x1","0").attr("x2","1").attr("y1","0").attr("y2","0")
  histoGradient.append('stop').attr('stop-color', d3.rgb("#2c3e50")).attr('offset', '84%');
  histoGradient.append('stop').attr('stop-color', d3.rgb("#d9d9db")).attr('offset', '16%');


//let ToggleBars = d3.select("#showBars")
let lineTrans = function(chart,duration,delay,easement){
  easement = easement || d3.easeLinear
  let lineLength =  function(chart){return chart.node().getTotalLength();}
  chart.attr("stroke-dasharray",0+" "+lineLength(chart))
      .transition()
      .duration(duration)
      .delay(delay)
      .ease(easement)
      .attr("stroke-dasharray",lineLength(chart)+" "+lineLength(chart))
}
let showBars = true
let automate = false

// d3.select("#mainView").append("svg").attr("id","confAnn")
//   .append("text").text("hello")
//   .attr("alignment-baseline","hanging")



function wrap(text, width) {
  text.each(function() {
    var text = d3.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        y = text.attr("y"),
        dy = parseFloat(text.attr("dy")),
        tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width) {
        line.pop();
        tspan.text(line.join(" "));
        line = [word];
        tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", 0.8 + "em").text(word);
      }
    }
  });
}


dataGeneration = function(){

    randomArray = function(size,mean,stdev){
      let array = [];
      for(let i=0; i<size; i++){
        let newNumber = d3.randomNormal(mean,stdev)();
        array.push(newNumber);
      }
      return array
    }

    firstPhase = randomArray(40,20,4)
    secondPhase = randomArray(30,17,3)
    thirdPhase = randomArray(15,18,4)


    combinedArray = firstPhase.concat(secondPhase,thirdPhase)

    mean = d3.mean(combinedArray,d => d)

    dict = []
    combinedArray.map(function(d,i){
      dict[i] = {"key":i,"value":d}
    })

  generateRunningSum = function(data){
  	rsData = data.map((d,i) => promise = {"key":i, "value": d.value, "delta": d.value - mean})

  	    var cumulative = 0;
  	    for (var i = 0; i < data.length; i++) {
  	      rsData[i].start = cumulative;
  	      cumulative += rsData[i].delta;
  	      rsData[i].end = cumulative;
  	      rsData[i].class = ( rsData[i].delta >= 0 ) ? 'positive' : 'negative'
  	    }

      rsMin = d3.min(rsData, d => Math.min(d.start,d.end))

      for (var i=0; i < rsData.length; i++){
 	    rsData[i].start = rsMin >= 0 ? rsData[i].start - rsMin : rsData[i].start + (rsMin*-1);
 	    rsData[i].end = rsMin >= 0 ? rsData[i].end - rsMin :  rsData[i].end + (rsMin*-1);
 	   }
      rsMax = d3.max(rsData, d => Math.max(d.start,d.end))
	  }
  generateRunningSum(dict)

  return {combinedArray,dict  }
}

getScales = function(data){
	let xScale = d3.scaleBand()
		 .domain(d3.range(data.length))
		 .range([0,w]);

	let yScale = d3.scaleLinear()
		.domain([d3.min(rsData,(d => d.value)), d3.max(rsData,(d => d.value))])
		.range([lineHeight,0]);

	let yScaleCUSUM = d3.scaleLinear()
		.domain([0,rsMax*1.6])
		.range([h,0]);

	let yScaleCSMheight = d3.scaleLinear()
		.domain([0, Math.abs(rsMax)])
		.range([h,0]);

	let xScaleCUSUM = d3.scaleBand()
		.domain(d3.range(rsData.length))
		.range([0,w]);


  return {xScale,yScale, xScaleCUSUM, yScaleCUSUM, yScaleCSMheight}
}

drawLine = function(data,scales){
  let {xScale,yScale} = scales;

   valueline = d3.line()
    .x(function(d,i){return xScale(i)})
    .y(d => yScale(d))


  let line = svg.append("g").attr("id","RL").append("path")
          .datum(data)
          .attr("d", valueline)
          .attr("class","line")
          lineTrans(line,4000,0)

  PageNum
    .append("text")
    .attr("text-anchor","middle")
    .text("1")
    .attr("dx",12)
    .attr("dy",22)


  AnnWindow
    .append("text").attr("class","ann1")
    .attr("text-anchor","left")
    .text("Take a time series")
    .attr("dy","1em")

  AnnWindow
    .append("text").attr("class","ann1")
    .attr("text-anchor","left")
    .text("...here is a generated trend")
    .transition().duration(4000)
    .attr("opacity",1)
    .attr("dy","2.5em")
    .attr("dx","0.5em")
    .on("end",
      function(){
        setTimeout(function(){
          //d3.select("#annCont").append("button").attr("id","next").text("next");
          nextButton.append("polygon").attr("id","next").attr("class","nextButton-ready")
            .attr("points","0,"+nextButtonSize+" "+nextButtonSize+","+nextButtonSize+" "+nextButtonSize+",0")
          nextButton.append("text").text("next").attr("id","nextText").attr("dy","0.68em").attr("dx","-0.25em")
          nextButton.append("rect").attr("id","nextOverlay").attr("width",nextButtonSize).attr("height",nextButtonSize).attr("opacity",0)
          stepSequencer(dict,scales)
        }, 500);
      }
    )



}

function wait(){
  d3.select("#next").attr("class","nextButton-waiting");
  d3.select("#nextOverlay").attr("class","noClick")
}
function ready(){
  d3.select("#next").attr("class","nextButton-ready");
  d3.select("#nextOverlay").attr("class",null)
}


stepSequencer = function(dict,scales){
  step = 1
  d3.select("#nextOverlay").on("click",function(){

    if (step == 1){
      wait();
      PageNum.select("text").text("2");
      d3.selectAll(".ann1").remove();

      AnnWindow
        .append("text").attr("class","ann2")
        .attr("text-anchor","left")
        .text("Calculate the deviations from mean")
        .transition().duration(800)
        .attr("opacity",1)
        .attr("dy","1em")
        .on("end", function(){
            drawMeanLine(dict,scales);
        })

      step = 2;

    } else if (step == 2) {
      AnnWindow.append("text").attr("class","ann2")
        .text("But how can we quantify and test this effect?")
        //.attr("y",AnnWindow.node().getBBox().height)
        .attr("dy","6.2em")
        .call(wrap,300)
        .transition().duration(800)
        .attr("opacity",1);

      step = 3;

    } else if (step == 3) {
      d3.select("#hG").remove();
      d3.selectAll(".ann2").remove();
      PageNum.select("text").text("3");
      wait();
      AnnWindow
        .append("text").attr("class","ann3")
        .attr("text-anchor","left")
        .text("By plotting the running sum of deltas, we get a curve describing the extent of segmentation within the trend")
        .attr("dy","1em")
        .call(wrap,300);

      //Grey out delta bars
      svg.selectAll("rect").transition().duration(2000).attr("fill","rgb(184,184,184)");

      setTimeout(function(){ready()},1500);

      step = 4;

    } else if (step == 4) {
      animateWaterfall(rsData, scales);
      step = 5;

    } else if (step == 5){
        AnnWindow.append("text").attr("class","ann3")
          .text("How can we tell whether the magnitude of change is convincing enough to declare a change in trend?")
          .attr("dy","4em")
          .call(wrap,300)
        step = 6;

    } else if (step == 6){

      d3.selectAll(".ann3").remove();
      d3.select("#cusumMaxAnn").remove();
      PageNum.select("text").text("4");

      AnnWindow.append("text").attr("class","ann4")
        .text("We can simulate chance by repeatedly shuffling the order of data points in the trend")
        .attr("dy","1em")
        .call(wrap,300)
       step = 7;

    } else if (step == 7){
      buttonWidth = 100;
      buttonHeight = 30;

      buttonG = annCont.append("g").attr("id","buttonG")

      function shuffleButton(){
        ShuffleButton = buttonG.append("svg")
          .attr("id","shuffleButton")
          .attr("class","shuffle-button")
          .attr("width", buttonWidth)
          .attr("height",buttonHeight)
        ShuffleButton.append("text")
          .attr("class","shuffle-text")
          .attr("x","50%")
          .attr("y","50%")
          .text("Shuffle")
          .attr("text-anchor","middle")
          .attr("dominant-baseline","middle")
        ShuffleButton.append("line")
          .attr("x1",0)
          .attr("x2",0)
          .attr("y1",buttonHeight-1)
          .attr("y2",buttonHeight-1)
          .attr("stroke-width", 2)
          .attr("stroke","black")
          .transition().duration(1500)
            .attr("x2",buttonWidth)
      }
      shuffleButton();

      shuffleData(dict,scales);

      step = 8;
    }

  })
}



drawMeanLine = function(dict,scales){
  let {yScale} = scales;
  let meanLine = svg.append("g").append("line").attr("id","meanLine")
    .attr("x1",0)
    .attr("x2",0)
    .attr("y1",yScale(mean))
    .attr("y2",yScale(mean))
    .attr("stroke","black")
    .transition().duration(1500)
    .attr("x2",w)
    .on("end",function(){
        drawBars(dict,scales);
      })

}


drawBars = function(data,scales){
  let {xScale,yScale} = scales;

  bars = svg.append("g").attr("id","devBars").selectAll("rect")
       .data(data, function(d){return d.key})
       .enter()
       .append("rect")
       .attr("x",function(d,i){return xScale(i)})
       .attr("y", yScale(mean))
       .attr("height",0)
       .attr("width", xScale.bandwidth())
       .attr("fill", d =>  d.value > mean ? "green" : "red")
       .attr('fill-opacity', 0.4)

       bars.transition()
       .duration(2000)
       //.delay(function(d,i){return i*50})
       .attr("height",d => Math.abs(yScale(mean) - yScale(d.value)))
       .attr("y",d => d.value > mean ? yScale(d.value) : yScale(mean))
       .end().then(() =>  {

          //Highlighted text
          hG = AnnWindow.append("g").attr("id","hG").attr("transform","translate(10,53)")

            hG.append("text")
              .text("...if ")

             let posText = hG
               .append("text")
               .attr("dx",hG.node().getBBox().width + 3)
               .text("positive")
             posBbox = posText.node().getBBox();


             hG.insert("rect","text").attr("id","posMask")
              .attr("x",posBbox.x-5)
              .attr("y",posBbox.y+6)
              .attr("width",posBbox.width+10)
              .attr("height",posBbox.height-10)
              .attr("fill","white")

             hG.insert("image","rect")
              .attr("x",posBbox.x-5)
              .attr("y",posBbox.y)
              .attr("width",posBbox.width+10)
              .attr("height",posBbox.height+2)
              .attr("xlink:href", "GreenHighlight.png")

             hG.append("text")
              .text("/")
              .attr("dx",hG.node().getBBox().width + 3)

             let negText = hG
               .append("text")
               .text("negative").attr("id","negText")
               .attr("dx",hG.node().getBBox().width+3)
              negBbox = d3.select("#negText").node().getBBox();

              hG.insert("rect","text").attr("id","negMask")
               .attr("x",negBbox.x-5)
               .attr("y",negBbox.y+6)
               .attr("width",negBbox.width+10)
               .attr("height",negBbox.height-10)
               .attr("fill","white")

              hG.insert("image","rect")
               .attr("x",negBbox.x-5)
               .attr("y",negBbox.y)
               .attr("width",negBbox.width+10)
               .attr("height",negBbox.height+2)
               .attr("xlink:href", "RedHighlight.png")

             hG.append("text")
              .attr("dx",hG.node().getBBox().width + 3)
              .text("deltas are clustered")

              hG.append("text")
               .attr("dy","0.9em")
               .text("together ->  this suggests the existince of distinct segments in the trend")
               .call(wrap,300)

              setTimeout(function(){
                d3.select("#posMask").transition().ease(d3.easeExp).duration(1000).attr("width",0).remove();
              },1200)
              setTimeout(function(){
                d3.select("#negMask").transition().ease(d3.easeExp).duration(1000).attr("width",0).remove();
                ready();
              },2200)


          //Hide bars on hover
          d3.select("#lineChart").on("mouseover", function(){
            svg.selectAll("rect")
            .transition()
            .attr("height", 0)
            .attr("y",yScale(mean))
          })

          d3.select("#lineChart").on("mouseout", function(){
              svg.selectAll("rect")
              .transition()
              .attr("height",d => Math.abs(yScale(mean) - yScale(d.value)))
              .attr("y",d => d.value > mean ? yScale(d.value) : yScale(mean))
            })

          d3.select("#lineChart").on("click", function(){
            svg.selectAll("rect")
            .attr("fill-opacity", showBars ? 0 : 0.4)

            d3.select("#meanLine")
            .attr("stroke-opacity", showBars ? 0 : 0.4)

            showBars =! showBars
          });

        })
      }


animateWaterfall = function(data, scales){
	let {xScale, yScale, yScaleCUSUM, yScaleCSMheight,xScaleCUSUM} = scales;

  //d3.select("#Ann1").transition().attr("opacity",0.3)

	rsData2 = []

	clickCount = 0

  //Draw CUSUM rect behind waterfall
  cusumSvg.append("rect").attr("id","cusumRect")
    .attr("x",0)
    .attr("y", yScaleCUSUM(rsMax))
    .attr("width",w)
    .attr("height", h - yScaleCUSUM(rsMax))
    .attr("fill", d3.rgb("#233240"))
    .attr("opacity", 0)

  //Annotation Callout Value
  cusumPeak = rsData.slice().sort((a, b) => d3.descending(a.end, b.end))


  //Cycle through updateData until all data points are rendered
  let duration = 120



  function pollDOM(){
    //if max point, draw callout, and then remove
    if (clickCount === cusumPeak[0].key){
      addDelta();
      setTimeout(Callout,100);
      setTimeout(function(){
        pollDOM();
        d3.select("#callout").remove();
      },4000);
    //if final point, trigger max line
    } else if (clickCount === rsData.length) {
      cusumMax(scales);
    //if another other point, cycle as normal
    } else {
      addDelta();
      setTimeout(pollDOM,duration);
    }
  }
  pollDOM();

  waterfallGroup = cusumSvg.append("g").attr("id","waterfallBars")

  function Callout(){
    //if (clickCount === cusumPeak[0].key) {
        highestValue = yScaleCUSUM(cusumPeak[0].end)
        highestIndex = xScaleCUSUM(cusumPeak[0].key)

        //Features of the annotation
        const annotations = [{
            note: {label: "If positve (or negative) deltas are clustered together, the curve will gain momentum, and grow taller", wrap:280},
            x: highestIndex, y: highestValue,
            dy: 50, dx: 50,
            subject: {radius: 35}
        }]

        //Add annotation to the Chart
        const makeAnnotations = d3.annotation()
          //.editMode(true)
          .type(d3.annotationCalloutCircle)
          .annotations(annotations)
        d3.select("#cusumSvg")
          .append("g").attr("id","callout")
          .call(makeAnnotations);


      };

  function addDelta(){
			rsData2[clickCount] = rsData[clickCount]

      yScaleCUSUM.domain([d3.min(rsData2,d => Math.min(d.end, d.start)) , d3.max(rsData2,d => Math.max(d.end, d.start)) * 1.6])
      yScaleCSMheight.domain([0 , (d3.max(rsData2,d => Math.max(d.end, d.start))*1.6) - d3.min(rsData2,d => Math.min(d.end, d.start))])

      clickCount ++


			waterfall = d3.select("#waterfallBars").selectAll("rect")
			      .data(rsData2)

			waterfallEnter = waterfall.enter()
			      .append("rect")
			      .attr("x",function(d,i){return xScaleCUSUM(i)})
			      .attr("y", d => yScaleCUSUM(d.start))
			      .attr("height", 0)
			      .attr("width", xScaleCUSUM.bandwidth())
			      .attr("fill", d => d.class === "positive"? "rgb(147,196,125)": "rgb(224,102,102)") //#94C895 = green | #FA9595 = red
			      .attr('fill-opacity', 1)

			waterfall.merge(waterfallEnter)
				.transition().duration(duration)
				.attr("y", d => yScaleCUSUM(Math.max(d.end, d.start)))
				.attr("height", d => h - yScaleCSMheight(Math.abs(d.end - d.start)))

      bars = svg.selectAll("rect")
        .attr("fill",(d,i) => i = rsData2[i] ? (d.value > mean ? "green" : "red") : "rgb(184,184,184)")

  		}


			shuffleCount = 0


}


cusumMax = function(scales){
	let {yScaleCUSUM} = scales

  origHeight = rsMax
  origHeight2 = rsMax - rsMin

  function cusumMaxAnn(){
        //Features of the annotation
        const annotations = [{
            note: {label: "The resulting curve height reflects the strength of the change-point effect, and becomes our test statistic", wrap:240},
            x: w, y: yScaleCUSUM(rsMax),
            dy: -20, dx: 20,
        }]

        //Add annotation to the Chart
        const makeAnnotations = d3.annotation()
          //.editMode(true)
          .type(d3.annotationCalloutElbow)
          .annotations(annotations)
        d3.select("#cusumSvg")
          .append("g").attr("id","cusumMaxAnn")
          .call(makeAnnotations);

        AnnConnector = d3.select("#cusumMaxAnn").selectAll(".connector")
        NoteLine = d3.select("#cusumMaxAnn").selectAll(".note-line")
        AnnText = d3.select("#cusumMaxAnn").selectAll(".annotation-note-label")
        lineTrans(AnnConnector,400,0)
        lineTrans(NoteLine,1000,400)
        AnnText.attr("opacity",0)
          .transition().delay(1200)
          .duration(500)
          .attr("opacity",1)

  }

  //Draw cusumHeightBars underneath OrigHeight line
  cusumSvg.append("g").attr("id","cusumHeightBars")


	cusumSvg.append("line")
		.attr("x1",0)
		.attr("x2",0)
		.attr("y1",yScaleCUSUM(rsMax))
		.attr("y2",yScaleCUSUM(rsMax))
		.attr("stroke","white")
		.transition()
    .duration(1500)
		.attr("x2",w)
    //.on("end",function(){cusumMaxAnn()})

  cusumSvg.select("#cusumRect")
    .transition()
    .duration(1500)
    .delay(1500)
    .attr("opacity", 1)
    .on("end",function(){ready();cusumMaxAnn();})

  xScaleCusumHeightInit = d3.scaleBand()
                      .domain(d3.range(100).reverse())
                      .range([0,w])


  xScaleCusumHeight = d3.scaleBand()
                      .domain(d3.range(cusumHeights.length))
                      .range([w,w*2])
                      .padding(0.1)


}


drawHisto = function(scales){
  let {yScaleCUSUM} = scales;

  histogram =  d3.histogram()
    .value(d => d)
    .domain(yScaleCUSUM.domain())
    .thresholds(yScaleCUSUM.ticks(45))

  bins = histogram(cusumHeights)

  histoX = d3.scaleLinear()
    .domain([0, d3.max(bins,function(d){return d.length;})])
    .range([0,85])

  histoSVG.append("g").attr("id","histoBars")
    .selectAll("rect")
    .data(bins)
    .enter()
    .append("rect")
      .attr("x",0)
      .attr("y",0)
      .attr("transform", function(d){return "translate(0, "+yScaleCUSUM(d.x1)+" )" })
      .attr("height",function(d){return yScaleCUSUM(d.x0) - yScaleCUSUM(d.x1); })
      .attr("width", 0)
      .style("fill", function(d){return (d.x0 + d.x1)/2  > rsMax ? "#ccffff" : "black"})
      .attr("opacity",function(d){return (d.x0 + d.x1)/2  > rsMax ? 0.4 : 0.2})

  histoSVG.append("g").attr("id","histoMX").append("line")
     .style("stroke","white")
     .attr("x1",0)
     .attr("x2",100)
     .attr("y1",yScaleCUSUM(rsMax))
     .attr("y2",yScaleCUSUM(rsMax))
     .attr("stroke-dasharray",[5,5])
     .style("opacity",0)

 simCount = histoSVG.append("g").attr("id","simCount")
  .attr("transform", "translate(55,"+(h-(h/20))+")")

 simCountNum = simCount.append("text").attr("class","num-text")
   .text(0)
   .attr("text-anchor","middle")
   .attr("dy","-1em")
   .attr("dx","-0.3em");

 simCountLab = simCount.append("text").attr("class","lab-text")
  .text("Simulations")
  .attr("text-anchor","middle")
  .attr("dx","-0.3em");


 hitRate= histoSVG.append("g").attr("id","hitRate")
  .attr("transform", "translate(55,"+h/15+")")

 hitRateNum = hitRate.append("text").attr("class","num-text")
   .text("0.0%")
   .style("font-size","20px")
   .attr("text-anchor","middle")
   .attr("dy","1em")
   .attr("dx","-0.3em");

 hitRateLab = hitRate.append("text").attr("class","lab-text")
  .text("Confidence")
  .attr("text-anchor","middle")
  .attr("dx","-0.3em");

  histoSVG.append("g").attr("transform","translate("+(histoWidth-15)+","+h/2+")")
    .append("text").attr("class","histo-lab")
    .text("Dist. of simulation scores")
    .attr("text-anchor","middle")









}


shuffleData = function(data,scales){
  d3.select("#ShuffleButton").on("click", function(){
    let {xScale,yScale,yScaleCUSUM,yScaleCSMheight,xScaleCUSUM} = scales;

    d3.select("#arrow").attr("opacity","1");
    d3.select("#circle").attr("opacity","1");

    //First Shuffle: Extend Max Line
    if (shuffleCount === 0){
        //Extend Max Line
        cusumSvg.select("line")
      		.attr("x2",w*2)
          .attr("stroke-dasharray",[5,5])

        d3.select("#histoMX")
          .select("line")
          .style("opacity",1)
    };
    ////////////////////////


    data2 = d3.shuffle(data)
    generateRunningSum(data2)


    //Shuffle Line
    valueline = d3.line()
     .x(function(d,i){return xScale(i)})
     .y(d => yScale(d.value))

     d3.select("#RL").selectAll("path")
      .datum(data)
      .transition()
      .duration(800)
      .attr("d", valueline)
      .attr("class","line")
      .attr("stroke-dasharray",[8000,8000])

    //Shuffle Bars
    svg.selectAll("rect")
    .data(data2,d => d.key)
      .transition()
      .duration(800)
        .attr("x", function(d,i){return xScale(i)})

    //Shuffle Waterfall
    d3.select("#waterfallBars").selectAll("rect")
    	.data(rsData)
    	.transition()
    	.duration(1000)
    	.attr("x",function(d,i){return xScaleCUSUM(i)})
      .attr("y", d => yScaleCUSUM(Math.max(d.end, d.start)))
      .attr("height", d => h - yScaleCSMheight(Math.abs(d.end - d.start)))
    	.attr("fill", d => d.class === "positive"? "rgb(147,196,125)": "rgb(224,102,102)")

    //Adjust CUSUM rect
    d3.select("#cusumRect")
      .transition()
      .duration(1000)
      .attr("y",  yScaleCUSUM(rsMax))
      .attr("height", h - yScaleCUSUM(rsMax))


  //First shuffle annotation
    if (shuffleCount == 0) {
      shuffleAnnG = cusumSvg.append("g")
        .attr("transform","translate("+(w+10)+","+yScaleCUSUM(rsMax)+")")
        .attr("class","lab-text").style("font-size",14)

      shuffleAnnText = shuffleAnnG
          .append("text")
          //.attr("alignment-baseline","hanging")
          .attr("id","firstSimAnn")

      shuffleAnnText
          .append("tspan")
          .attr("x",0)
          .attr("dy","1em")
          .text("The shuffled trend has a    ")

      shuffleAnnText.append("tspan").text("lower").attr("id","lower")

      shuffleAnnG.insert("rect","text").attr("id","lowerRect")
      .attr("x", d3.select("#lower").node().getExtentOfChar(0).x-6)
      .attr("y",d3.select("#lower").node().getExtentOfChar(0).y)
      .attr("width",d3.select("#lower").node().getComputedTextLength()+10)
      .attr("height",d3.select("#lower").node().getExtentOfChar(0).height)
      .attr("rx",5)
      .attr("fill",d3.rgb("#233240"))

      shuffleAnnText.append("tspan").text("   change-point")
      shuffleAnnText.append("tspan")
      .attr("x",0)
      .attr("dy","1em")
      .text("score than our original trend.")

      shuffleAnnText
        .append("tspan")
        //.attr("x",0)
        .attr("dy","2em")
        .text("Keep shufflin' to build up a distribution of simulation scores.")
        .call(wrap,300)
        .attr("opacity",0)
        .transition().duration(1000).delay(2000)
        .attr("opacity",1)

    }

    //Update CUSUM Height Bars
    if (shuffleCount > 0) {
      shuffleAnnG.remove();

      //If fewer than 100 bars, scale to data length, else limit to 50
      xScaleCusumHeight.domain(d3.range(cusumHeightsDict.length < 50 ? cusumHeightsDict.length : 50).reverse())

      //If fewer than 100 values, take all values, else limit to last 50
  	  last50 = cusumHeightsDict.slice(cusumHeightsDict.length < 50 ? 0 : cusumHeightsDict.length-50 , cusumHeightsDict.length+1)

      cusumHeightBars = d3.select("#cusumHeightBars")
          .selectAll("rect")
          .data(last50, key = d => d.key)

  	  cusumHeightBars.enter()
  		  .append("rect")
  		  .attr("x",0)
  		  .attr("y",  yScaleCUSUM(cusumHeights[shuffleCount-1]))
  		  .attr("height", h - yScaleCUSUM(cusumHeights[shuffleCount-1]))
  		  .attr("width",w)
        .attr("class", cusumHeights[shuffleCount-1] > origHeight ? "over" : "under")
  		  .attr("opacity",0.5)
  			.merge(cusumHeightBars)
  			.transition()
  			.duration(500)
  			.attr("x",function(d,i){return xScaleCusumHeight(i)})
  			.attr("width",xScaleCusumHeight.bandwidth())
        .attr("opacity",1)

  	  cusumHeightBars.exit()
  		 .transition()
  		 .duration(1000)
  		 .attr("transform","translate("+w+",0)")
  		 .remove()

       hitRate = 100 - (d3.sum(cusumHeights,d => d > origHeight ? 1 : 0) / shuffleCount * 100)
       hitRate = hitRate.toFixed(1)+"%"
       hitRateNum.text(hitRate)

       //Update histogram
       let bins = histogram(cusumHeights)

       histoX.domain([0, d3.max(bins,function(d){return d.length;})])

       d3.select("#histoBars").selectAll("rect")
         .data(bins)
         .transition()
         .duration(1000)
           .attr("transform", function(d){return "translate(0, "+yScaleCUSUM(d.x1)+" )" })
           .attr("height",function(d){return yScaleCUSUM(d.x0) - yScaleCUSUM(d.x1); })
           .attr("width", function(d){return histoX(d.length);})

      simCountNum.text(shuffleCount)

    }

    //Show chart re-set button
    if (shuffleCount == 3) {
      buttonSize = 35

      resetSvg = d3.select("#lineChartCont").append("svg").attr("id","resetButton")
        .attr("viewBox","0 0 100 100")
        .attr("width",buttonSize)
        .attr("height",buttonSize)

      resetCircle = resetSvg.append("path").attr("id","circle")
        .attr("d",'M20 50, A30 30, 0, 0 0, 80 50, A30 30, 0, 0 0, 27 30')
        .attr("stroke","#a9a9a9").attr("stroke-width","7px")
        .attr("fill","none")

      resetSvg.on("mouseover",function(){
        d3.select("#circle")
        lineTrans(resetCircle,1200,0)
      })
      resetSvg.on("mouseout",function(){
        d3.select("#circle")
        lineTrans(resetCircle,0,0)
      })


      resetArrow = resetSvg.append("polygon").attr("id","arrow")
        .attr("points","5,50 35,50 20,70")
        .attr("fill","#a9a9a9")

      showOrigTrend(dict,scales);
    }

    //Show automateShuffle button
    if (shuffleCount == 6) {
      function shuffleButton2(){
        ShuffleButton2 = buttonG.append("svg")
          .attr("class","shuffle-button").attr("id","autoButton")
          .attr("width", buttonWidth*1.3)
          .attr("height",buttonHeight)
        ShuffleButton2.append("text")
          .attr("class","shuffle-text").attr("id","autoText")
          .attr("x","50%")
          .attr("y","50%")
          .text("Auto-Shuffle")
          .attr("text-anchor","middle")
          .attr("dominant-baseline","middle")
        ShuffleButton2.append("line")
          .attr("x1",0)
          .attr("x2",0)
          .attr("y1",buttonHeight-1)
          .attr("y2",buttonHeight-1)
          .attr("stroke-width", 2)
          .attr("stroke","black")
          .transition().duration(1500)
            .attr("x2",buttonWidth*1.3)
      }
      shuffleButton2();

      shuffleInterval(dict,scales);
    }


  //Push latest CUSUM heights to dataset and increment the shuffleCount
   shuffleCount++

   cusumHeights.push(rsMax)
   cusumHeightsDict.push({"key":shuffleCount,"value":rsMax})

    })
  }

shuffleInterval = function(dict,scales){
  d3.select("#autoButton").on("click", function(){
    automate =! automate
    if (automate){
      inter = setInterval(function() {
        automateShuffle(dict,scales);
        ;
      }, 100);
      d3.select("#autoText").text("Pause");
    } else {
      clearInterval(inter);
      d3.select("#autoText").text("Auto-Shuffle");
    }
  })
}

automateShuffle = function(data,scales){

    let {yScaleCUSUM} = scales;

    let duration = 100

    data2 = d3.shuffle(data)
    generateRunningSum(data2)
		shuffleCount ++
		cusumHeights.push(rsMax)
    cusumHeightsDict.push({"key":shuffleCount,"value":rsMax})

    //If fewer than 50 values, take all values, else limit to last 50
	  last50 = cusumHeightsDict.slice(cusumHeightsDict.length < 50 ? 0 : cusumHeightsDict.length-50 , cusumHeightsDict.length+1)
    //If fewer than 50 bars, scale to data length, else limit to 50
    xScaleCusumHeight.domain(d3.range(cusumHeightsDict.length < 50 ? cusumHeightsDict.length : 50).reverse())


      cusumHeightBars = d3.select("#cusumHeightBars")
          .selectAll("rect")
          .data(last50, key = d => d.key)


      cusumHeightBars.enter()
          .append("rect")
		      .attr("x",w - xScaleCusumHeight.bandwidth())
          .attr("y", d => yScaleCUSUM(d.value))
          .attr("height", d => h - yScaleCUSUM(d.value))
          .attr("opacity", 0)
          .attr("class", d => d.value > origHeight ? "over" : "under")
          .merge(cusumHeightBars)
          .transition()
          .duration(duration)
          .attr("x",function(d,i){return xScaleCusumHeight(i)})
          .attr("width",xScaleCusumHeight.bandwidth())
          .attr("opacity", 1)


	   cusumHeightBars.exit()
		 .transition()
		 .duration(duration)
		 .attr("transform","translate("+xScaleCusumHeight.bandwidth()+",0)")
		 .remove()

      let bins = histogram(cusumHeights)

      histoX.domain([0, d3.max(bins,function(d){return d.length;})])

      d3.select("#histoBars").selectAll("rect")
        .data(bins)
        .transition()
        .duration(duration)
          .attr("transform", function(d){return "translate(0, "+yScaleCUSUM(d.x1)+" )" })
          .attr("height",function(d){return yScaleCUSUM(d.x0) - yScaleCUSUM(d.x1); })
          .attr("width", function(d){return histoX(d.length);})
        //  .on("end",function(){automateShuffle(dict,scales)})

      simCountNum.text(shuffleCount)
      hitRate = 100 - (d3.sum(cusumHeights,d => d > origHeight ? 1 : 0) / shuffleCount * 100)
      hitRate = hitRate.toFixed(1)+"%"
      hitRateNum.text(hitRate)

}

showOrigTrend = function(data,scales){
  let {xScale,yScale,yScaleCUSUM,yScaleCSMheight,xScaleCUSUM} = scales;

  d3.select("#resetButton").on("click",function(){
    d3.select("#arrow").attr("opacity","0.3");
    d3.select("#circle").attr("opacity","0.3");

    data = dict.sort(function(a,b){return a.key - b.key})
    generateRunningSum(data)

    //Shuffle Line
    valueline = d3.line()
     .x(function(d,i){return xScale(i)})
     .y(d => yScale(d.value))

     d3.select("#RL").selectAll("path")
      .datum(data)
      .transition()
      .duration(1000)
      .attr("d", valueline)
      .attr("class","line")

    //Shuffle Bars
    svg.selectAll("rect")
    .data(data,d => d.key)
      .transition()
      .duration(1000)
        .attr("x", function(d,i){return xScale(i)})

    //Shuffle Waterfall
    d3.select("#waterfallBars").selectAll("rect")
      .data(rsData)
      .transition()
      .duration(1000)
      .attr("x",function(d,i){return xScaleCUSUM(i)})
      .attr("y", d => yScaleCUSUM(Math.max(d.end, d.start)))
      .attr("height", d => h - yScaleCSMheight(Math.abs(d.end - d.start)))
      .attr("fill", d => d.class === "positive"? "rgb(147,196,125)": "rgb(224,102,102)")

    //Adjust CUSUM rect
    d3.select("#cusumRect")
      .transition()
      .duration(1000)
      .attr("y",  yScaleCUSUM(rsMax))
      .attr("height", h - yScaleCUSUM(rsMax))
  })
}


//histoBox = d3.select("#histoChart").node().getClientRects()[0]
//circleCentre = [histoBox.x + histoBox.width/2, histoBox.y]

// function sketchyAnn(circleCentre,circleSize){
//
//
//   radius = circleSize/2.3
//
//   sketchyBox = d3.select("#mainView").append("svg").attr("id","sketchyBox")
//   .attr("width",circleSize*3).attr("height",circleSize*2)
//   .style("left",histoBox.x)
//   .style("top",histoBox.y - (histoBox.height/3))
//
//
//
//   var r = radius, c = circleCentre, w = 1, fillColor = "red", strokeColor = "black";
//
//   r = r*1.5;
//   //divide width by two to get the offset
//   var z = w /2;
//   var gCirclePoints = [];
//   gCirclePoints.push([c[0],c[1] + r - (r * .25)]);
//   gCirclePoints.push([c[0] + (r + (z * .375)) * .3,c[1] + (r - (r * 0.3)) * .9]);
//   gCirclePoints.push([c[0] + (r * .9) + (z * .375),c[1] - (r * .1)]);
//   gCirclePoints.push([c[0],c[1] - (r * 1) - (z * .5)]);
//   gCirclePoints.push([c[0] - (r * .9) - (z * .35),c[1] - (r * .1)]);
//   gCirclePoints.push([c[0] - (r + (z * .95)) * .4,c[1] + (r - (r * .25)) * .9]);
//   gCirclePoints.push([c[0],c[1] + (r * .9) + (z) - (r * .2)]);
//   gCirclePoints.push([c[0],c[1] + (r * .9) - (z) - (r * .25)]);
//
//
//   sketchyC = d3.line()
//     .x(function(d,i){return d[0]})
//     .y(function(d) {return d[1]})
//     .curve(d3.curveBasis)
//
//   sketchyBox.append("path").attr("id","sketchPath")
//     .attr("d",sketchyC(gCirclePoints))
//     .style("stroke", "black")
//     .style("stroke-width",0.8)
//     .style("fill", "none")
//
//   lineTrans(d3.select("#sketchPath"),1500,0,d3.easeExp)
//
//
//   var gLinePoints = [
//     [(circleCentre[0]) + circleSize/2.2 * Math.cos(30 * (Math.PI/180)),
//      (circleCentre[1]) - circleSize/2.2 * Math.sin(30 * (Math.PI/180))]
//      ,
//     [(circleCentre[0]) + circleSize/1.5 * Math.cos(30 * (Math.PI/180)),
//      (circleCentre[1]) - circleSize/1.5 * Math.sin(30 * (Math.PI/180))]
//      ,
//     [(circleCentre[0])  + circleSize * Math.cos(22 * (Math.PI/180)),
//      (circleCentre[0])  - circleSize * Math.sin(22 * (Math.PI/180))]
//   ];
//
//
//   sketchyBox.append("path").attr("id","sketchLine")
//     .attr("d",sketchyC(gLinePoints))
//     .style("stroke", "black")
//     .style("stroke-width",0.8)
//     .style("fill", "none")
//
//   lineTrans(d3.select("#sketchLine"),700,1000,d3.easeExp)
//
// }
//
// sketchyAnn([65,100],150)

showData = function(){
  dataGeneration();
  let scales = getScales(dict);
  drawLine(combinedArray,scales);
  cusumHeights = [];
  cusumHeightsDict = [];
  drawHisto(scales);
}
showData();


</script>

</html>
