<html>

<head>
    <style>
      /*CSS Styling*/
      .line {
      stroke-width: 1px;
      stroke: grey;
      fill: none
      }
      .mean {
      stroke-width: 1px;
      stroke: black;
      }
      .canvas {
      display:flex;
      flex-direction: column;
      }
      .subdiv {
      display:flex;
      flex-direction: row;
      }
      .bottomContainer {
      display:flex;
      flex-direction: column;
      }
      .over {
      fill: url(#gradient)
      }
      .under {
      fill: #233240
      }
      #histo-container {
      margin-left: 10px;
      }

      h1, h2, h3, h4, h5, h6 {
        font-family: "Bitter";
        fill: #2c3e50;
      }
      .lab-text {
        fill: #78909c;
        font-size: 13px;
        font-family: "Bitter"
      }
      .num-text {
        fill: #78909c;
        font-family: "Bitter"
      }
      #lineChartCont {
        background: #F7F8F9;
        border: 1px solid #d9d9db;
        border-radius: 10px;
      }
      .annotation-note-label {
        fill: #78909c;
        font-size: 13px;
        font-family: "Bitter"
      }
      .subject,.note-line,.connector {
        stroke: white;
        stroke-width: 1.2px;
      }
      #mainView {
        padding-top: 20px;
        padding-left: 20px;
      }
      #topView {
        padding-bottom: 20px;
      }
      #title {
        color: #2c3e50;
        font-size: 23px;
        font-family: "Bitter";
        padding-bottom: 10px;
      }
      #annCont {
        padding-left: 20px;
        /*background: no-repeat left/380px 250px url('Paper.PNG');*/
      }
      #AnnSvg {
        background: no-repeat left/450px 100% url('Paper.PNG');
        font-family: "Caveat"
      }
      #histoLab {
        font-family: "Bitter";
        font-size: 16px;
        color: #b5b5b5;
        transform: rotate(90deg) translate(1.2em,-1.6em);
        transform-origin: 0 0
      }
      #histo-container {
        border: 0px;
        border-radius: 10px;
      }
      .histoBackground {
        fill: url(#histoGrad);
      }

    </style>

  <!-- Load d3 -->
  <script src="https://d3js.org/d3.v5.min.js"></script>

  <!-- Load bootstrap -->
  <script src="http://code.jquery.com/jquery.js"></script>
  <link href="../bootstrap-4.4.1-dist/css/bootstrap.min.css" rel="stylesheet" media="screen">
  <script src="../bootstrap-4.4.1-dist/js/bootstrap.min.js"></script>

  <!-- Load d3-annotation -->
  <script src="https://rawgit.com/susielu/d3-annotation/master/d3-annotation.min.js"></script>

</head>


<body>

<div class="btn-group" role="group" aria-label="Basic example">
	<button type="button" class="btn btn-info" id="Shuffle">Scramble Once</button>
	<button type="button" class="btn btn-primary" id="shuffleBatch" >start</button>
</div>
  <div class="button"><button id="resetOrig" type="button">Reset Orig</button></div>
  <div id="mainView" class = "canvas">
      <div id="title">ChangePoint Analysis</div>
      <div id="topView" class = "subdiv">
        <div id="lineChartCont" class = "canvas"></div>
        <div id="annCont"></div>
      <!--  <div class="button"><button id="showBars" type="button">Toggle Bars</button></div>-->
      </div>
      <div class = "bottomContainer">
        <h5>Simulation statistics</h5>
        <div id="bottomView" class = "subdiv">
          <div id="cusumView"></div>
          <div id="histoView" class = "subdiv">
            <div id="histoChart"></div>
            <div id="histoLab"></div>
          </div>
        </div>
      </div>
  </div>
  </div>
</body>



<script>

w = 400
h = 250

//let svg = d3.select("#topView").append("svg").attr("id","line-chart").attr("width",w).attr("height",h).style("border-radius", "10px").style("background-color", "#F7F8F9")
let lineMargin = {top: 50, right: 0, bottom: 30, left: 0};
let lineWidth = w - lineMargin.left - lineMargin.right,
    lineHeight = h - lineMargin.top - lineMargin.bottom;

let svg = d3.select("#lineChartCont").append("svg").attr("id","lineChart")
  .attr("width", w)
  .attr("height", h)
  .append("g")
    .attr("transform", "translate("+lineMargin.left+", "+lineMargin.top+")")
let AnnSvg = d3.select("#annCont")
  .append("svg")
  .attr("id","AnnSvg")
  .attr("width",450)
  .attr("height",h)
  .append("g").attr("transform","translate(45,32)")



let cusumSvg = d3.select("#cusumView").append("svg").attr("id","cusumSvg").attr("width", w*2).attr("height", h).style("border-style", "solid").style("border-width", "0px").style("border-radius", "10px").style("background-color", "#2c3e50")
var gradient = svg.append("linearGradient").attr("id","gradient").attr("x1","0").attr("x2","0").attr("y1","0").attr("y2","1")
  gradient.append('stop').attr('stop-color', d3.rgb("#78909c")).attr('offset', '0%');
  gradient.append('stop').attr('stop-color', d3.rgb("#4e616e")).attr('offset', '33%');
  gradient.append('stop').attr('stop-color', d3.rgb("#233240")).attr('offset', '95%');
let histoSVG = d3.select("#histoChart").append("svg").attr("id","histo-container").attr("width",125).attr("height",h)
let histoBackground = histoSVG.append("rect").attr("class","histoBackground").attr("width",125).attr("height",h)
//d3.select("#histoLab").text("Dist. of simulation scores")
var histoGradient = histoSVG.append("linearGradient").attr("id","histoGrad").attr("x1","0").attr("x2","1").attr("y1","0").attr("y2","0")
  histoGradient.append('stop').attr('stop-color', d3.rgb("#2c3e50")).attr('offset', '82%');
  histoGradient.append('stop').attr('stop-color', d3.rgb("#b7b7b7")).attr('offset', '18%');

let Button = d3.select("#Shuffle")
//let ToggleBars = d3.select("#showBars")
let lineTrans = function(chart,duration,delay){
  let lineLength =  function(chart){return chart.node().getTotalLength();}
  chart.attr("stroke-dasharray",0+" "+lineLength(chart))
      .transition()
      .duration(duration)
      .delay(delay)
      .ease(d3.easeLinear)
      .attr("stroke-dasharray",lineLength(chart)+" "+lineLength(chart))
}
let showBars = true
let automate = false



dataGeneration = function(){

    randomArray = function(size,mean,stdev){
      let array = [];
      for(let i=0; i<size; i++){
        let newNumber = d3.randomNormal(mean,stdev)();
        array.push(newNumber);
      }
      return array
    }

    firstPhase = randomArray(40,20,4)
    secondPhase = randomArray(30,17,3)
    thirdPhase = randomArray(15,18,4)


    combinedArray = firstPhase.concat(secondPhase,thirdPhase)

    mean = d3.mean(combinedArray,d => d)

    dict = []
    combinedArray.map(function(d,i){
      dict[i] = {"key":i,"value":d}
    })

  generateRunningSum = function(data){
  	rsData = data.map((d,i) => promise = {"key":i, "value": d.value, "delta": d.value - mean})

  	    var cumulative = 0;
  	    for (var i = 0; i < data.length; i++) {
  	      rsData[i].start = cumulative;
  	      cumulative += rsData[i].delta;
  	      rsData[i].end = cumulative;
  	      rsData[i].class = ( rsData[i].delta >= 0 ) ? 'positive' : 'negative'
  	    }

      rsMin = d3.min(rsData, d => Math.min(d.start,d.end))

      for (var i=0; i < rsData.length; i++){
 	    rsData[i].start = rsMin >= 0 ? rsData[i].start - rsMin : rsData[i].start + (rsMin*-1);
 	    rsData[i].end = rsMin >= 0 ? rsData[i].end - rsMin :  rsData[i].end + (rsMin*-1);
 	   }
      rsMax = d3.max(rsData, d => Math.max(d.start,d.end))
	  }
  generateRunningSum(dict)

  return {combinedArray,dict  }
}

getScales = function(data){
	let xScale = d3.scaleBand()
		 .domain(d3.range(data.length))
		 .range([0,w]);

	let yScale = d3.scaleLinear()
		.domain([d3.min(rsData,(d => d.value)), d3.max(rsData,(d => d.value))])
		.range([lineHeight,0]);

	let yScaleCUSUM = d3.scaleLinear()
		.domain([0,rsMax*1.6])
		.range([h,0]);

	let yScaleCSMheight = d3.scaleLinear()
		.domain([0, Math.abs(rsMax)])
		.range([h,0]);

	let xScaleCUSUM = d3.scaleBand()
		.domain(d3.range(rsData.length))
		.range([0,w]);


  return {xScale,yScale, xScaleCUSUM, yScaleCUSUM, yScaleCSMheight}
}

drawLine = function(data,scales){
  let {xScale,yScale} = scales;

   valueline = d3.line()
    .x(function(d,i){return xScale(i)})
    .y(d => yScale(d))


  let line = svg.append("g").attr("id","RL").append("path")
          .datum(data)
          .attr("d", valueline)
          .attr("class","line")
          lineTrans(line,4000,0)

  AnnSvg
    .append("text").attr("id","Ann1")
    .attr("text-anchor","left")
    .text("1. take a time series")
    .attr("opacity",1)
    .attr("dy","1em")

  let meanLine = svg.append("g").append("line")
    .attr("x1",0)
	  .attr("x2",0)
	  .attr("y1",yScale(mean))
	  .attr("y2",yScale(mean))
	  .attr("stroke","black")
	  .transition().duration(1500).delay(4000)
    .attr("x2",w).on("end",
      function(){
        AnnSvg.append("text").attr("id","deltaAnn")
          .text("2. calculate differences from the trend mean")
          .attr("opacity",0)
          .attr("dy","2.5em")
          .transition().duration(500).attr("opacity",1);
        setTimeout(function(){drawBars(dict,scales);}, 500);
        d3.select("#Ann1").transition().attr("opacity",0.3)
      }
    )

}

drawBars = function(data,scales){
  let {xScale,yScale} = scales;

  bars = svg.append("g").attr("id","devBars").selectAll("rect")
       .data(data, function(d){return d.key})
       .enter()
       .append("rect")
       .attr("x",function(d,i){return xScale(i)})
       .attr("y", yScale(mean))
       .attr("height",0)
       .attr("width", xScale.bandwidth())
       //.attr("fill", "grey")
       .attr("fill", d =>  d.value > mean ? "green" : "red")
       .attr('fill-opacity', 0.4)

       bars.transition()
       .duration(2000)
       //.delay(function(d,i){return i*50})
       .attr("height",d => Math.abs(yScale(mean) - yScale(d.value)))
       .attr("y",d => d.value > mean ? yScale(d.value) : yScale(mean))
       .end().then(() => {
         setTimeout(function(){animateWaterfall(rsData, scales);}, 2000);
         setTimeout(function(){bars.transition().duration(800).attr("fill","rgb(184,184,184)");}, 500);
         d3.select("#deltaAnn").transition().duration(500).attr("opacity",0.3)
       });

  d3.select("#lineChartCont").append("button").attr("id","toggleBars").text("Toggle")
  toggleBars();
}

toggleBars = function(){
  d3.select("#toggleBars").on("click", function(){
    svg.selectAll("rect")
    .attr("fill-opacity", showBars ? 0 : 0.4)

    showBars =! showBars
})}


animateWaterfall = function(data, scales){
	let {xScale, yScale, yScaleCUSUM, yScaleCSMheight,xScaleCUSUM} = scales;

  d3.select("#Ann1").transition().attr("opacity",0.3)

  AnnSvg
    .append("text").attr("id","rsAnn")
    .attr("text-anchor","left")
    .text("3. plot the running sum of deltas")
    .attr("opacity",1)
    .attr("dy","4em")

	rsData2 = []

	clickCount = 0

  //Draw CUSUM rect behind waterfall
  cusumSvg.append("rect").attr("id","cusumRect")
    .attr("x",0)
    .attr("y", yScaleCUSUM(rsMax))
    .attr("width",w)
    .attr("height", h - yScaleCUSUM(rsMax))
    .attr("fill", d3.rgb("#233240"))
    .attr("opacity", 0)

  //Annotation Callout Value
  cusumPeak = rsData.slice().sort((a, b) => d3.descending(a.end, b.end))

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }


  //Cycle through updateData until all data points are rendered
  let duration = 120

  function pollDOM(){
    //if max point, draw callout, and then remove
    if (clickCount === cusumPeak[0].key){
      addDelta();
      setTimeout(Callout,100);
      setTimeout(function(){
        pollDOM();
        d3.select("#callout").remove();
      },4000);
    //if final point, trigger max line
    } else if (clickCount === rsData.length) {
      cusumMax(scales);
    //if another other point, cycle as normal
    } else {
      addDelta();
      setTimeout(pollDOM,duration);
    }
  }
  pollDOM();

  waterfallGroup = cusumSvg.append("g").attr("id","waterfallBars")

  function Callout(){
    //if (clickCount === cusumPeak[0].key) {
        highestValue = yScaleCUSUM(cusumPeak[0].end)
        highestIndex = xScaleCUSUM(cusumPeak[0].key)

        //Features of the annotation
        const annotations = [{
            note: {label: "If pos or neg deltas are clustered together, the curve will gain momentum, and grow taller", wrap:250},
            x: highestIndex, y: highestValue,
            dy: 50, dx: 50,
            subject: {radius: 35}
        }]

        //Add annotation to the Chart
        const makeAnnotations = d3.annotation()
          //.editMode(true)
          .type(d3.annotationCalloutCircle)
          .annotations(annotations)
        d3.select("#cusumSvg")
          .append("g").attr("id","callout")
          .call(makeAnnotations);
        //d3.select(".annotation-note-label").attr("width",600)
      };

  function addDelta(){
			rsData2[clickCount] = rsData[clickCount]

      yScaleCUSUM.domain([d3.min(rsData2,d => Math.min(d.end, d.start)) , d3.max(rsData2,d => Math.max(d.end, d.start)) * 1.6])
      yScaleCSMheight.domain([0 , (d3.max(rsData2,d => Math.max(d.end, d.start))*1.6) - d3.min(rsData2,d => Math.min(d.end, d.start))])

      clickCount ++


			waterfall = d3.select("#waterfallBars").selectAll("rect")
			      .data(rsData2)

			waterfallEnter = waterfall.enter()
			      .append("rect")
			      .attr("x",function(d,i){return xScaleCUSUM(i)})
			      .attr("y", d => yScaleCUSUM(d.start))
			      .attr("height", 0)
			      .attr("width", xScaleCUSUM.bandwidth())
			      .attr("fill", d => d.class === "positive"? "rgb(147,196,125)": "rgb(224,102,102)") //#94C895 = green | #FA9595 = red
			      .attr('fill-opacity', 1)

			waterfall.merge(waterfallEnter)
				.transition().duration(duration)
				.attr("y", d => yScaleCUSUM(Math.max(d.end, d.start)))
				.attr("height", d => h - yScaleCSMheight(Math.abs(d.end - d.start)))

      bars = svg.selectAll("rect")
        .attr("fill",(d,i) => i = rsData2[i] ? (d.value > mean ? "green" : "red") : "rgb(184,184,184)")

  		}


			shuffleCount = 0


}


cusumMax = function(scales){
	let {yScaleCUSUM} = scales

  origHeight = rsMax
  origHeight2 = rsMax - rsMin

  //Draw cusumHeightBars underneath OrigHeight line
  cusumSvg.append("g").attr("id","cusumHeightBars")

	cusumSvg.append("line")
		.attr("x1",0)
		.attr("x2",0)
		.attr("y1",yScaleCUSUM(rsMax))
		.attr("y2",yScaleCUSUM(rsMax))
		.attr("stroke","white")
		.transition()
    .duration(1500)
		.attr("x2",w)

  cusumSvg.select("#cusumRect")
    .transition()
    .duration(4000)
    .delay(500)
    .attr("opacity", 1)

  xScaleCusumHeightInit = d3.scaleBand()
                      .domain(d3.range(100).reverse())
                      .range([0,w])


  xScaleCusumHeight = d3.scaleBand()
                      .domain(d3.range(cusumHeights.length))
                      .range([w,w*2])
                      .padding(0.1)



}

drawHisto = function(scales){
  let {yScaleCUSUM} = scales;

  histogram =  d3.histogram()
    .value(d => d)
    .domain(yScaleCUSUM.domain())
    .thresholds(yScaleCUSUM.ticks(40))

  bins = histogram(cusumHeights)

  histoX = d3.scaleLinear()
    .domain([0, d3.max(bins,function(d){return d.length;})])
    .range([0,85])

  histoSVG.append("g").attr("id","histoBars")
    .selectAll("rect")
    .data(bins)
    .enter()
    .append("rect")
      .attr("x",0)
      .attr("y",0)
      .attr("transform", function(d){return "translate(0, "+yScaleCUSUM(d.x1)+" )" })
      .attr("height",function(d){return yScaleCUSUM(d.x0) - yScaleCUSUM(d.x1); })
      .attr("width", 0)
      .style("fill", function(d){return (d.x0 + d.x1)/2  > rsMax ? "#ccffff" : "black"})
      .attr("opacity",function(d){return (d.x0 + d.x1)/2  > rsMax ? 0.4 : 0.2})

  histoSVG.append("g").attr("id","histoMX").append("line")
     .style("stroke","white")
     .attr("x1",0)
     .attr("x2",100)
     .attr("y1",yScaleCUSUM(rsMax))
     .attr("y2",yScaleCUSUM(rsMax))
     .attr("stroke-dasharray",[5,5])
     .style("opacity",0)

 simCount = histoSVG.append("g").attr("id","simCount")
  .attr("transform", "translate(50,"+(h-(h/20))+")")

 simCountNum = simCount.append("text").attr("class","num-text")
   .text(0)
   .attr("text-anchor","middle")
   .attr("dy","-1em")
   .attr("dx","-0.3em");

 simCountLab = simCount.append("text").attr("class","lab-text")
  .text("Simulations")
  .attr("text-anchor","middle")
  .attr("dx","-0.3em");


 hitRate= histoSVG.append("g").attr("id","hitRate")
  .attr("transform", "translate(50,"+h/15+")")

 hitRateNum = hitRate.append("text").attr("class","num-text")
   .text("0.0%")
   .style("font-size","20px")
   .attr("text-anchor","middle")
   .attr("dy","1em")
   .attr("dx","-0.3em");

 hitRateLab = hitRate.append("text").attr("class","lab-text")
  .text("Hit Rate")
  .attr("text-anchor","middle")
  .attr("dx","-0.3em");




}




shuffleData = function(data,scales){
  Button.on("click", function(){
    let {xScale,yScale,yScaleCUSUM,yScaleCSMheight,xScaleCUSUM} = scales;


    //First Shuffle: Original Line Chart Thumbnail + Extend Max Line
    if (shuffleCount === 0){
       //
	     // originLineSvg = d3.select("#topView")
       //    .append("svg")
       //    .attr("width", 100)
       //    .attr("height",60)
       //    .style("border-radius", "6px")
       //    .style("background-color", "#F7F8F9")
       //    .style("margin-left","10px")
       //
	     //  let shrunkenX = d3.scaleBand()
			 //     .domain(d3.range(combinedArray.length))
			 //     .range([0,100])
       //
	     //  let shrunkenY = d3.scaleLinear()
			 //    .domain([d3.min(combinedArray), d3.max(combinedArray)])
			 //    .range([60,0])
       //
	     //  shrunkenValueLine = d3.line()
	     //   .x(function(d,i){return shrunkenX(i)})
	     //   .y(d => shrunkenY(d))
       //
  	   //  originLineSvg.append("g").attr("id","OL").append("path")
  		 //  .datum(combinedArray)
  		 //  .attr("d", shrunkenValueLine)
  		 //  .attr("class","line")
  		 //  .style("stroke-width","0.5px")

        //Extend Max Line
        cusumSvg.select("line")
      		.attr("x2",w*2)
          .attr("stroke-dasharray",[5,5])

        d3.select("#histoMX")
          .select("line")
          .style("opacity",1)
    };
    ////////////////////////


    data2 = d3.shuffle(data)
    generateRunningSum(data2)


    //Shuffle Line
    valueline = d3.line()
     .x(function(d,i){return xScale(i)})
     .y(d => yScale(d.value))

     d3.select("#RL").selectAll("path")
      .datum(data)
      .transition()
      .duration(800)
      .attr("d", valueline)
      .attr("class","line")
      .attr("stroke-dasharray",[8000,8000])

    //Shuffle Bars
    svg.selectAll("rect")
    .data(data2,d => d.key)
      .transition()
      .duration(800)
        .attr("x", function(d,i){return xScale(i)})

    //Shuffle Waterfall
    d3.select("#waterfallBars").selectAll("rect")
    	.data(rsData)
    	.transition()
    	.duration(1000)
    	.attr("x",function(d,i){return xScaleCUSUM(i)})
      .attr("y", d => yScaleCUSUM(Math.max(d.end, d.start)))
      .attr("height", d => h - yScaleCSMheight(Math.abs(d.end - d.start)))
    	.attr("fill", d => d.class === "positive"? "rgb(147,196,125)": "rgb(224,102,102)")

    //Adjust CUSUM rect
    d3.select("#cusumRect")
      .transition()
      .duration(1000)
      .attr("y",  yScaleCUSUM(rsMax))
      .attr("height", h - yScaleCUSUM(rsMax))

    //Update CUSUM Height Bars
    if (shuffleCount > 0) {

      //If fewer than 100 bars, scale to data length, else limit to 100
      xScaleCusumHeight.domain(d3.range(cusumHeightsDict.length < 50 ? cusumHeightsDict.length : 50).reverse())

      //If fewer than 100 values, take all values, else limit to last 100
  	  last100 = cusumHeightsDict.slice(cusumHeightsDict.length < 50 ? 0 : cusumHeightsDict.length-50 , cusumHeightsDict.length+1)

      cusumHeightBars = d3.select("#cusumHeightBars")
          .selectAll("rect")
          .data(last100, key = d => d.key)

  	  cusumHeightBars.enter()
  		  .append("rect")
  		  .attr("x",0)
  		  .attr("y",  yScaleCUSUM(cusumHeights[shuffleCount-1]))
  		  .attr("height", h - yScaleCUSUM(cusumHeights[shuffleCount-1]))
  		  .attr("width",w)
        .attr("class", cusumHeights[shuffleCount-1] > origHeight ? "over" : "under")
  		  .attr("opacity",0.5)
  			.merge(cusumHeightBars)
  			.transition()
  			.duration(500)
  			.attr("x",function(d,i){return xScaleCusumHeight(i)})
  			.attr("width",xScaleCusumHeight.bandwidth())
        .attr("opacity",1)

  	  cusumHeightBars.exit()
  		 .transition()
  		 .duration(1000)
  		 .attr("transform","translate("+w+",0)")
  		 .remove()

       hitRate = d3.sum(cusumHeights,d => d > origHeight ? 1 : 0) / shuffleCount * 100
       hitRate = hitRate.toFixed(1)+"%"
       hitRateNum.text(hitRate)

       //Update histogram
       let bins = histogram(cusumHeights)

       histoX.domain([0, d3.max(bins,function(d){return d.length;})])

       d3.select("#histoBars").selectAll("rect")
         .data(bins)
         .transition()
         .duration(1000)
           .attr("transform", function(d){return "translate(0, "+yScaleCUSUM(d.x1)+" )" })
           .attr("height",function(d){return yScaleCUSUM(d.x0) - yScaleCUSUM(d.x1); })
           .attr("width", function(d){return histoX(d.length);})

      simCountNum.text(shuffleCount)
    }


  //Push latest CUSUM heights to dataset and increment the shuffleCount
   shuffleCount++

   cusumHeights.push(rsMax)
   cusumHeightsDict.push({"key":shuffleCount,"value":rsMax})

    })
  }


shuffleInterval = function(dict,scales){
  d3.select("#shuffleBatch").on("click", function(){
    automate =! automate
    if (automate){
      inter = setInterval(function() {
        automateShuffle(dict,scales);
      }, 100);
      d3.select(this).text("stop");
    } else {
      clearInterval(inter);
      d3.select(this).text("start");
    }
  })
}


automateShuffle = function(data,scales){

    let {yScaleCUSUM} = scales;

    let duration = 100

    data2 = d3.shuffle(data)
    generateRunningSum(data2)
		shuffleCount ++
		cusumHeights.push(rsMax)
    cusumHeightsDict.push({"key":shuffleCount,"value":rsMax})

    //If fewer than 100 values, take all values, else limit to last 100
	  last100 = cusumHeightsDict.slice(cusumHeightsDict.length < 50 ? 0 : cusumHeightsDict.length-50 , cusumHeightsDict.length+1)

    //If fewer than 100 bars, scale to data length, else limit to 100
    xScaleCusumHeight.domain(d3.range(cusumHeightsDict.length < 50 ? cusumHeightsDict.length : 50).reverse())


      cusumHeightBars = d3.select("#cusumHeightBars")
          .selectAll("rect")
          .data(last100, key = d => d.key)


      cusumHeightBars.enter()
          .append("rect")
		      .attr("x",w - xScaleCusumHeight.bandwidth())
          .attr("y", d => yScaleCUSUM(d.value))
          .attr("height", d => h - yScaleCUSUM(d.value))
          .attr("opacity", 0)
          .attr("class", d => d.value > origHeight ? "over" : "under")
          .merge(cusumHeightBars)
          .transition()
          .duration(duration)
          .attr("x",function(d,i){return xScaleCusumHeight(i)})
          .attr("width",xScaleCusumHeight.bandwidth())
          .attr("opacity", 1)


	   cusumHeightBars.exit()
		 .transition()
		 .duration(duration)
		 .attr("transform","translate("+xScaleCusumHeight.bandwidth()+",0)")
		 .remove()

      let bins = histogram(cusumHeights)

      histoX.domain([0, d3.max(bins,function(d){return d.length;})])

      d3.select("#histoBars").selectAll("rect")
        .data(bins)
        .transition()
        .duration(duration)
          .attr("transform", function(d){return "translate(0, "+yScaleCUSUM(d.x1)+" )" })
          .attr("height",function(d){return yScaleCUSUM(d.x0) - yScaleCUSUM(d.x1); })
          .attr("width", function(d){return histoX(d.length);})
        //  .on("end",function(){automateShuffle(dict,scales)})

      simCountNum.text(shuffleCount)
      hitRate = d3.sum(cusumHeights,d => d > origHeight ? 1 : 0) / shuffleCount * 100
      hitRate = hitRate.toFixed(1)+"%"
      hitRateNum.text(hitRate)

}

showOrigTrend = function(data,scales){
  let {xScale,yScale,yScaleCUSUM,yScaleCSMheight,xScaleCUSUM} = scales;

  d3.select("#resetOrig").on("click",function(){
    data = dict.sort(function(a,b){return a.key - b.key})
    generateRunningSum(data)

    //Shuffle Line
    valueline = d3.line()
     .x(function(d,i){return xScale(i)})
     .y(d => yScale(d.value))

     d3.select("#RL").selectAll("path")
      .datum(data)
      .transition()
      .duration(1000)
      .attr("d", valueline)
      .attr("class","line")

    //Shuffle Bars
    svg.selectAll("rect")
    .data(data,d => d.key)
      .transition()
      .duration(1000)
        .attr("x", function(d,i){return xScale(i)})

    //Shuffle Waterfall
    d3.select("#waterfallBars").selectAll("rect")
      .data(rsData)
      .transition()
      .duration(1000)
      .attr("x",function(d,i){return xScaleCUSUM(i)})
      .attr("y", d => yScaleCUSUM(Math.max(d.end, d.start)))
      .attr("height", d => h - yScaleCSMheight(Math.abs(d.end - d.start)))
      .attr("fill", d => d.class === "positive"? "rgb(147,196,125)": "rgb(224,102,102)")

    //Adjust CUSUM rect
    d3.select("#cusumRect")
      .transition()
      .duration(1000)
      .attr("y",  yScaleCUSUM(rsMax))
      .attr("height", h - yScaleCUSUM(rsMax))
  })
}


showData = function(){
  dataGeneration();
  let scales = getScales(dict);
  drawLine(combinedArray,scales);
  cusumHeights = [];
  cusumHeightsDict = [];
  //toggleBars();
  drawHisto(scales);
  shuffleData(dict,scales);
  shuffleInterval(dict,scales);
  showOrigTrend(dict,scales)
}
showData();


</script>

</html>
