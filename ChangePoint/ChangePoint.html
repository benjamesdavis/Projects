<html>

<head>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Caveat">
    <style>
      /*CSS Styling*/
      .line {
      stroke-width: 1px;
      stroke: grey;
      fill: none
      }
      .mean {
      stroke-width: 1px;
      stroke: black;
      }
      .canvas {
      display:flex;
      flex-direction: column;
      }
      .subdiv {
      display:flex;
      flex-direction: row;
      }
      .bottomContainer {
      display:flex;
      flex-direction: column;
      }
      .over {
      fill: url(#gradient)
      }
      .under {
      fill: #233240
      }
      #histo-container {
      margin-left: 10px;
      }

      h1, h2, h3, h4, h5, h6 {
        font-family: "Bitter";
        fill: #2c3e50;
      }
      .lab-text {
        fill: #78909c;
        font-size: 13px;
        font-family: "Bitter"
      }
      .num-text {
        fill: #78909c;
        font-family: "Bitter"
      }
      #lineChartCont {
        background: #F7F8F9;
        border: 1px solid #d9d9db;
        border-radius: 10px;
        position: relative;
      }
      .annotation-note-label {
        fill: #78909c;
        font-size: 13px;
        font-family: "Bitter"
      }
      .subject,.note-line,.connector {
        stroke: white;
        stroke-width: 1.2px;
      }
      #mainView {
        padding-top: 20px;
        padding-left: 20px;
      }
      #topView {
        padding-bottom: 20px;
      }
      #title {
        color: #2c3e50;
        font-size: 23px;
        font-family: "Bitter";
        padding-bottom: 10px;
      }
      #annCont {
        margin-left: 20px;
        height: 250px;
        width: 400px;
      }
      #AnnWindow, #pageNum{
        font-family: "Caveat";
        font-size: 22px;
      }
      @keyframes fadein {
        from { opacity: 0; }
        to   { opacity: 1; }
      }
      #hG {
        font-size: 20px;
        animation: fadein 3s;
      }
      .histo-lab {
        fill: #9d9d9d;
        font-family: "Bitter";
        font-size: 13px;
        letter-spacing: 1.5px;
        transform: rotate(90deg);
      }
      #histo-container {
        border: 0px;
        border-radius: 10px;
      }
      .histoBackground {
        fill: url(#histoGrad);
      }
      #cardSvg {
        background: no-repeat left/100% 100% url('Paper.PNG');
      }
      @keyframes glowing {
        0% { fill: #dadada;  }
        50% { fill: #ababac;  }
        100% { fill: #dadada; }
      }
      .nextButton-ready {
        animation: glowing 1500ms infinite  !important;
      }
      .nextButton-waiting {
        fill: #dadada;
      }
      .noClick{
        pointer-events: none;
      }
      #nextText {
        transform-origin: right top;
        transform: rotate(315deg);
        font-family: "Caveat";
        font-size: 20px;
        fill: white;
        user-select: none;
      }
      #toggleBars {
        position: absolute; right:5; top:5;
      }
      #callout {
        font-family: "Caveat";
        font-size: 20px;
      }



    </style>

  <!-- Load d3 -->
  <script src="https://d3js.org/d3.v5.min.js"></script>

  <!-- Load bootstrap -->
  <script src="http://code.jquery.com/jquery.js"></script>
  <link href="../bootstrap-4.4.1-dist/css/bootstrap.min.css" rel="stylesheet" media="screen">
  <script src="../bootstrap-4.4.1-dist/js/bootstrap.min.js"></script>

  <!-- Load d3-annotation -->
  <script src="https://rawgit.com/susielu/d3-annotation/master/d3-annotation.min.js"></script>

</head>


<body>

<!--<div class="btn-group" role="group" aria-label="Basic example">
	<button type="button" class="btn btn-primary" id="shuffleBatch" >start</button>
</div>-->
  <div class="button"><button id="resetOrig" type="button">Reset Orig</button></div>
  <div id="mainView" class = "canvas">
      <div id="title">ChangePoint Analysis</div>
      <div id="topView" class = "subdiv">
        <div id="lineChartCont" class = "canvas"></div>
        <div id="annCont"></div>
      <!--  <div class="button"><button id="showBars" type="button">Toggle Bars</button></div>-->
      </div>
      <div class = "bottomContainer">
        <h5>Simulation statistics</h5>
        <div id="bottomView" class = "subdiv">
          <div id="cusumView"></div>
          <div id="histoView" class = "subdiv">
            <div id="histoChart"></div>
            <div id="histoLab"></div>
          </div>
        </div>
      </div>
  </div>
  </div>
</body>



<script>

w = 400
h = 250

let lineMargin = {top: 45, right: 0, bottom: 30, left: 0};
let lineWidth = w - lineMargin.left - lineMargin.right,
    lineHeight = h - lineMargin.top - lineMargin.bottom;

let svg = d3.select("#lineChartCont").append("svg").attr("id","lineChart")
  .attr("transform", "translate("+lineMargin.left+", "+lineMargin.top+")")
  .attr("width", w)
  .attr("height", h-lineMargin.top-lineMargin.bottom)

let cardSvg = d3.select("#annCont").append("svg").attr("width",w).attr("height",h).attr("id","cardSvg")


let AnnWindow= cardSvg.append("svg").append("g").attr("transform","translate(55,32)").attr("id","AnnWindow")

//cardSvg.append("svg").attr("id","test").attr("x",50).attr("y",50)
let PageNum = cardSvg.append("svg").attr("id","pageNum")
  .append("g").attr("transform","translate(358,5)")

PageNum.append("svg:image")
  .attr("width",30)
  .attr("height",30)
  .attr("xlink:href", "penCircle.png")


let nextButtonSize = 38
let nextButton = cardSvg
  .append("svg")
  .attr("width",nextButtonSize)
  .attr("height",nextButtonSize)
  .attr("x",357)
  .attr("y",h-44)


let cusumSvg = d3.select("#cusumView").append("svg").attr("id","cusumSvg").attr("width", w*2).attr("height", h).style("border-style", "solid").style("border-width", "0px").style("border-radius", "10px").style("background-color", "#2c3e50")
var gradient = svg.append("linearGradient").attr("id","gradient").attr("x1","0").attr("x2","0").attr("y1","0").attr("y2","1")
  gradient.append('stop').attr('stop-color', d3.rgb("#78909c")).attr('offset', '0%');
  gradient.append('stop').attr('stop-color', d3.rgb("#4e616e")).attr('offset', '33%');
  gradient.append('stop').attr('stop-color', d3.rgb("#233240")).attr('offset', '95%');

histoWidth = 125
let histoSVG = d3.select("#histoChart").append("svg").attr("id","histo-container").attr("width",histoWidth).attr("height",h)
let histoBackground = histoSVG.append("rect").attr("class","histoBackground").attr("width",histoWidth).attr("height",h)
var histoGradient = histoSVG.append("linearGradient").attr("id","histoGrad").attr("x1","0").attr("x2","1").attr("y1","0").attr("y2","0")
  histoGradient.append('stop').attr('stop-color', d3.rgb("#2c3e50")).attr('offset', '84%');
  histoGradient.append('stop').attr('stop-color', d3.rgb("#d9d9db")).attr('offset', '16%');


//let ToggleBars = d3.select("#showBars")
let lineTrans = function(chart,duration,delay){
  let lineLength =  function(chart){return chart.node().getTotalLength();}
  chart.attr("stroke-dasharray",0+" "+lineLength(chart))
      .transition()
      .duration(duration)
      .delay(delay)
      .ease(d3.easeLinear)
      .attr("stroke-dasharray",lineLength(chart)+" "+lineLength(chart))
}
let showBars = true
let automate = false


function wrap(text, width) {
  text.each(function() {
    var text = d3.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        y = text.attr("y"),
        dy = parseFloat(text.attr("dy")),
        tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width) {
        line.pop();
        tspan.text(line.join(" "));
        line = [word];
        tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", 0.8 + "em").text(word);
      }
    }
  });
}





dataGeneration = function(){

    randomArray = function(size,mean,stdev){
      let array = [];
      for(let i=0; i<size; i++){
        let newNumber = d3.randomNormal(mean,stdev)();
        array.push(newNumber);
      }
      return array
    }

    firstPhase = randomArray(40,20,4)
    secondPhase = randomArray(30,17,3)
    thirdPhase = randomArray(15,18,4)


    combinedArray = firstPhase.concat(secondPhase,thirdPhase)

    mean = d3.mean(combinedArray,d => d)

    dict = []
    combinedArray.map(function(d,i){
      dict[i] = {"key":i,"value":d}
    })

  generateRunningSum = function(data){
  	rsData = data.map((d,i) => promise = {"key":i, "value": d.value, "delta": d.value - mean})

  	    var cumulative = 0;
  	    for (var i = 0; i < data.length; i++) {
  	      rsData[i].start = cumulative;
  	      cumulative += rsData[i].delta;
  	      rsData[i].end = cumulative;
  	      rsData[i].class = ( rsData[i].delta >= 0 ) ? 'positive' : 'negative'
  	    }

      rsMin = d3.min(rsData, d => Math.min(d.start,d.end))

      for (var i=0; i < rsData.length; i++){
 	    rsData[i].start = rsMin >= 0 ? rsData[i].start - rsMin : rsData[i].start + (rsMin*-1);
 	    rsData[i].end = rsMin >= 0 ? rsData[i].end - rsMin :  rsData[i].end + (rsMin*-1);
 	   }
      rsMax = d3.max(rsData, d => Math.max(d.start,d.end))
	  }
  generateRunningSum(dict)

  return {combinedArray,dict  }
}

getScales = function(data){
	let xScale = d3.scaleBand()
		 .domain(d3.range(data.length))
		 .range([0,w]);

	let yScale = d3.scaleLinear()
		.domain([d3.min(rsData,(d => d.value)), d3.max(rsData,(d => d.value))])
		.range([lineHeight,0]);

	let yScaleCUSUM = d3.scaleLinear()
		.domain([0,rsMax*1.6])
		.range([h,0]);

	let yScaleCSMheight = d3.scaleLinear()
		.domain([0, Math.abs(rsMax)])
		.range([h,0]);

	let xScaleCUSUM = d3.scaleBand()
		.domain(d3.range(rsData.length))
		.range([0,w]);


  return {xScale,yScale, xScaleCUSUM, yScaleCUSUM, yScaleCSMheight}
}

drawLine = function(data,scales){
  let {xScale,yScale} = scales;

   valueline = d3.line()
    .x(function(d,i){return xScale(i)})
    .y(d => yScale(d))


  let line = svg.append("g").attr("id","RL").append("path")
          .datum(data)
          .attr("d", valueline)
          .attr("class","line")
          lineTrans(line,4000,0)

  PageNum
    .append("text")
    .attr("text-anchor","middle")
    .text("1")
    .attr("dx",12)
    .attr("dy",22)


  AnnWindow
    .append("text").attr("class","ann1")
    .attr("text-anchor","left")
    .text("Take a time series")
    .attr("dy","1em")

  AnnWindow
    .append("text").attr("class","ann1")
    .attr("text-anchor","left")
    .text("...here is a random trend")
    .transition().duration(4000)
    .attr("opacity",1)
    .attr("dy","2.5em")
    .attr("dx","0.5em")
    .on("end",
      function(){
        setTimeout(function(){
          //d3.select("#annCont").append("button").attr("id","next").text("next");
          nextButton.append("polygon").attr("id","next").attr("class","nextButton-ready")
            .attr("points","0,"+nextButtonSize+" "+nextButtonSize+","+nextButtonSize+" "+nextButtonSize+",0")
          nextButton.append("text").text("next").attr("id","nextText").attr("dy","0.68em").attr("dx","-0.25em")
          nextButton.append("rect").attr("id","nextOverlay").attr("width",nextButtonSize).attr("height",nextButtonSize).attr("opacity",0)
          stepSequencer(dict,scales)
        }, 500);
      }
    )



}

function wait(){
  d3.select("#next").attr("class","nextButton-waiting");
  d3.select("#nextOverlay").attr("class","noClick")
}
function ready(){
  d3.select("#next").attr("class","nextButton-ready");
  d3.select("#nextOverlay").attr("class",null)
}

step = 1
stepSequencer = function(dict,scales){
  d3.select("#nextOverlay").on("click",function(){

    if (step == 1){
      wait();
      PageNum.select("text").text("2");
      d3.selectAll(".ann1").remove();

      AnnWindow
        .append("text").attr("class","ann2")
        .attr("text-anchor","left")
        .text("Calculate the deviations from mean")
        .transition().duration(800)
        .attr("opacity",1)
        .attr("dy","1em")
        .on("end", function(){
            drawMeanLine(dict,scales);
        })

      step = 2;

    } else if (step == 2) {
      AnnWindow.append("text").attr("class","ann2")
        .text("But how can we quantify this effect?")
        .attr("y",AnnWindow.node().getBBox().height)
        .attr("dy","1.1em")
        .transition().duration(800)
        .attr("opacity",1);

      step = 3;

    } else if (step == 3) {
      d3.select("#hG").remove();
      wait();
      d3.selectAll(".ann2").remove();
      PageNum.select("text").text("3");
      animateWaterfall(rsData, scales);
      step = 4;

    } else if (step ==4){
      AnnWindow.append("text").attr("class","ann3")
        .text("How can we tell whether this change-point is significant?")
        .attr("dy","2.5em")
        .call(wrap,300)
      step = 5;

    } else if (step == 5){

      d3.selectAll(".ann3").remove();
      d3.select("#cusumMaxAnn").remove();
      PageNum.select("text").text("4");

      d3.select("#annCont").append("button").attr("class","btn btn-info").attr("id","Shuffle").text("shuffle");
      shuffleData(dict,scales);

      step = 6;

    }


  })
}



drawMeanLine = function(dict,scales){
  let {yScale} = scales;
  let meanLine = svg.append("g").append("line").attr("id","meanLine")
    .attr("x1",0)
    .attr("x2",0)
    .attr("y1",yScale(mean))
    .attr("y2",yScale(mean))
    .attr("stroke","black")
    .transition().duration(1500)
    .attr("x2",w)
    .on("end",function(){
        setTimeout(function(){drawBars(dict,scales)},500);
      })

}


drawBars = function(data,scales){
  let {xScale,yScale} = scales;

  bars = svg.append("g").attr("id","devBars").selectAll("rect")
       .data(data, function(d){return d.key})
       .enter()
       .append("rect")
       .attr("x",function(d,i){return xScale(i)})
       .attr("y", yScale(mean))
       .attr("height",0)
       .attr("width", xScale.bandwidth())
       .attr("fill", d =>  d.value > mean ? "green" : "red")
       .attr('fill-opacity', 0.4)

       bars.transition()
       .duration(2000)
       //.delay(function(d,i){return i*50})
       .attr("height",d => Math.abs(yScale(mean) - yScale(d.value)))
       .attr("y",d => d.value > mean ? yScale(d.value) : yScale(mean))
       .end().then(() =>  {

        //Highlighted text
        hG = AnnWindow.append("g").attr("id","hG").attr("transform","translate(10,53)")

          hG.append("text")
            .text("...if ")

           let posText = hG
             .append("text")
             .attr("dx",hG.node().getBBox().width + 3)
             .text("positive")
           posBbox = posText.node().getBBox();


           hG.insert("rect","text").attr("id","posMask")
            .attr("x",posBbox.x-5)
            .attr("y",posBbox.y+6)
            .attr("width",posBbox.width+10)
            .attr("height",posBbox.height-10)
            .attr("fill","white")

           hG.insert("image","rect")
            .attr("x",posBbox.x-5)
            .attr("y",posBbox.y)
            .attr("width",posBbox.width+10)
            .attr("height",posBbox.height+2)
            .attr("xlink:href", "GreenHighlight.png")

           hG.append("text")
            .text("/")
            .attr("dx",hG.node().getBBox().width + 3)

           let negText = hG
             .append("text")
             .text("negative").attr("id","negText")
             .attr("dx",hG.node().getBBox().width+3)
            negBbox = d3.select("#negText").node().getBBox();

            hG.insert("rect","text").attr("id","negMask")
             .attr("x",negBbox.x-5)
             .attr("y",negBbox.y+6)
             .attr("width",negBbox.width+10)
             .attr("height",negBbox.height-10)
             .attr("fill","white")

            hG.insert("image","rect")
             .attr("x",negBbox.x-5)
             .attr("y",negBbox.y)
             .attr("width",negBbox.width+10)
             .attr("height",negBbox.height+2)
             .attr("xlink:href", "RedHighlight.png")

           hG.append("text")
            .attr("dx",hG.node().getBBox().width + 3)
            .text("deltas are clustered")

            hG.append("text")
             .attr("dy","0.9em")
             .text("together ->  this suggests the existince of distinct segments in the trend")
             .call(wrap,300)

            setTimeout(function(){
              d3.select("#posMask").transition().duration(500).attr("width",0).remove();
            },1200)
            setTimeout(function(){
              d3.select("#negMask").transition().duration(500).attr("width",0).remove();
              ready();
            },2200)


       });


  d3.select("#lineChartCont").append("button").attr("id","toggleBars")
    .text("Toggle")

  toggleBars();
}

toggleBars = function(){
  d3.select("#toggleBars").on("click", function(){
    svg.selectAll("rect")
    .attr("fill-opacity", showBars ? 0 : 0.4)

    d3.select("#meanLine")
    .attr("stroke-opacity", showBars ? 0 : 0.4)

    showBars =! showBars
})}


animateWaterfall = function(data, scales){
	let {xScale, yScale, yScaleCUSUM, yScaleCSMheight,xScaleCUSUM} = scales;

  d3.select("#Ann1").transition().attr("opacity",0.3)

  AnnWindow
    .append("text").attr("class","ann3")
    .attr("text-anchor","left")
    .text("Plot the running sum of deltas")
    .attr("dy","1em")

	rsData2 = []

	clickCount = 0

  //Draw CUSUM rect behind waterfall
  cusumSvg.append("rect").attr("id","cusumRect")
    .attr("x",0)
    .attr("y", yScaleCUSUM(rsMax))
    .attr("width",w)
    .attr("height", h - yScaleCUSUM(rsMax))
    .attr("fill", d3.rgb("#233240"))
    .attr("opacity", 0)

  //Annotation Callout Value
  cusumPeak = rsData.slice().sort((a, b) => d3.descending(a.end, b.end))


  //Cycle through updateData until all data points are rendered
  let duration = 120



  function pollDOM(){
    //if max point, draw callout, and then remove
    if (clickCount === cusumPeak[0].key){
      addDelta();
      setTimeout(Callout,100);
      setTimeout(function(){
        pollDOM();
        d3.select("#callout").remove();
      },4000);
    //if final point, trigger max line
    } else if (clickCount === rsData.length) {
      cusumMax(scales);
    //if another other point, cycle as normal
    } else {
      addDelta();
      setTimeout(pollDOM,duration);
    }
  }
  pollDOM();

  waterfallGroup = cusumSvg.append("g").attr("id","waterfallBars")

  function Callout(){
    //if (clickCount === cusumPeak[0].key) {
        highestValue = yScaleCUSUM(cusumPeak[0].end)
        highestIndex = xScaleCUSUM(cusumPeak[0].key)

        //Features of the annotation
        const annotations = [{
            note: {label: "If pos or neg deltas are clustered together, the curve will gain momentum, and grow taller", wrap:250},
            x: highestIndex, y: highestValue,
            dy: 50, dx: 50,
            subject: {radius: 35}
        }]

        //Add annotation to the Chart
        const makeAnnotations = d3.annotation()
          //.editMode(true)
          .type(d3.annotationCalloutCircle)
          .annotations(annotations)
        d3.select("#cusumSvg")
          .append("g").attr("id","callout")
          .call(makeAnnotations);


      };

  function addDelta(){
			rsData2[clickCount] = rsData[clickCount]

      yScaleCUSUM.domain([d3.min(rsData2,d => Math.min(d.end, d.start)) , d3.max(rsData2,d => Math.max(d.end, d.start)) * 1.6])
      yScaleCSMheight.domain([0 , (d3.max(rsData2,d => Math.max(d.end, d.start))*1.6) - d3.min(rsData2,d => Math.min(d.end, d.start))])

      clickCount ++


			waterfall = d3.select("#waterfallBars").selectAll("rect")
			      .data(rsData2)

			waterfallEnter = waterfall.enter()
			      .append("rect")
			      .attr("x",function(d,i){return xScaleCUSUM(i)})
			      .attr("y", d => yScaleCUSUM(d.start))
			      .attr("height", 0)
			      .attr("width", xScaleCUSUM.bandwidth())
			      .attr("fill", d => d.class === "positive"? "rgb(147,196,125)": "rgb(224,102,102)") //#94C895 = green | #FA9595 = red
			      .attr('fill-opacity', 1)

			waterfall.merge(waterfallEnter)
				.transition().duration(duration)
				.attr("y", d => yScaleCUSUM(Math.max(d.end, d.start)))
				.attr("height", d => h - yScaleCSMheight(Math.abs(d.end - d.start)))

      bars = svg.selectAll("rect")
        .attr("fill",(d,i) => i = rsData2[i] ? (d.value > mean ? "green" : "red") : "rgb(184,184,184)")

  		}


			shuffleCount = 0


}


cusumMax = function(scales){
	let {yScaleCUSUM} = scales

  origHeight = rsMax
  origHeight2 = rsMax - rsMin

  function cusumMaxAnn(){
        //Features of the annotation
        const annotations = [{
            note: {label: "The resulting curve height reflects the strength of the change-point effect, and becomes our test statistic", wrap:240},
            x: w, y: yScaleCUSUM(rsMax),
            dy: -20, dx: 20,
        }]

        //Add annotation to the Chart
        const makeAnnotations = d3.annotation()
          //.editMode(true)
          .type(d3.annotationCalloutElbow)
          .annotations(annotations)
        d3.select("#cusumSvg")
          .append("g").attr("id","cusumMaxAnn")
          .call(makeAnnotations);

        AnnConnector = d3.select("#cusumMaxAnn").selectAll(".connector")
        NoteLine = d3.select("#cusumMaxAnn").selectAll(".note-line")
        AnnText = d3.select("#cusumMaxAnn").selectAll(".annotation-note-label")
        lineTrans(AnnConnector,400,0)
        lineTrans(NoteLine,1000,400)
        AnnText.attr("opacity",0)
          .transition().delay(1200)
          .duration(500)
          .attr("opacity",1)

  }

  //Draw cusumHeightBars underneath OrigHeight line
  cusumSvg.append("g").attr("id","cusumHeightBars")


	cusumSvg.append("line")
		.attr("x1",0)
		.attr("x2",0)
		.attr("y1",yScaleCUSUM(rsMax))
		.attr("y2",yScaleCUSUM(rsMax))
		.attr("stroke","white")
		.transition()
    .duration(1500)
		.attr("x2",w)
    //.on("end",function(){cusumMaxAnn()})

  cusumSvg.select("#cusumRect")
    .transition()
    .duration(1500)
    .delay(1500)
    .attr("opacity", 1)
    .on("end",function(){ready();cusumMaxAnn();})

  xScaleCusumHeightInit = d3.scaleBand()
                      .domain(d3.range(100).reverse())
                      .range([0,w])


  xScaleCusumHeight = d3.scaleBand()
                      .domain(d3.range(cusumHeights.length))
                      .range([w,w*2])
                      .padding(0.1)


}




drawHisto = function(scales){
  let {yScaleCUSUM} = scales;

  histogram =  d3.histogram()
    .value(d => d)
    .domain(yScaleCUSUM.domain())
    .thresholds(yScaleCUSUM.ticks(45))

  bins = histogram(cusumHeights)

  histoX = d3.scaleLinear()
    .domain([0, d3.max(bins,function(d){return d.length;})])
    .range([0,85])

  histoSVG.append("g").attr("id","histoBars")
    .selectAll("rect")
    .data(bins)
    .enter()
    .append("rect")
      .attr("x",0)
      .attr("y",0)
      .attr("transform", function(d){return "translate(0, "+yScaleCUSUM(d.x1)+" )" })
      .attr("height",function(d){return yScaleCUSUM(d.x0) - yScaleCUSUM(d.x1); })
      .attr("width", 0)
      .style("fill", function(d){return (d.x0 + d.x1)/2  > rsMax ? "#ccffff" : "black"})
      .attr("opacity",function(d){return (d.x0 + d.x1)/2  > rsMax ? 0.4 : 0.2})

  histoSVG.append("g").attr("id","histoMX").append("line")
     .style("stroke","white")
     .attr("x1",0)
     .attr("x2",100)
     .attr("y1",yScaleCUSUM(rsMax))
     .attr("y2",yScaleCUSUM(rsMax))
     .attr("stroke-dasharray",[5,5])
     .style("opacity",0)

 simCount = histoSVG.append("g").attr("id","simCount")
  .attr("transform", "translate(55,"+(h-(h/20))+")")

 simCountNum = simCount.append("text").attr("class","num-text")
   .text(0)
   .attr("text-anchor","middle")
   .attr("dy","-1em")
   .attr("dx","-0.3em");

 simCountLab = simCount.append("text").attr("class","lab-text")
  .text("Simulations")
  .attr("text-anchor","middle")
  .attr("dx","-0.3em");


 hitRate= histoSVG.append("g").attr("id","hitRate")
  .attr("transform", "translate(55,"+h/15+")")

 hitRateNum = hitRate.append("text").attr("class","num-text")
   .text("0.0%")
   .style("font-size","20px")
   .attr("text-anchor","middle")
   .attr("dy","1em")
   .attr("dx","-0.3em");

 hitRateLab = hitRate.append("text").attr("class","lab-text")
  .text("Hit Rate")
  .attr("text-anchor","middle")
  .attr("dx","-0.3em");

  histoSVG.append("g").attr("transform","translate("+(histoWidth-15)+","+h/2+")")
    .append("text").attr("class","histo-lab")
    .text("Dist. of simulation scores")
    .attr("text-anchor","middle")









}




shuffleData = function(data,scales){
  d3.select("#Shuffle").on("click", function(){
    let {xScale,yScale,yScaleCUSUM,yScaleCSMheight,xScaleCUSUM} = scales;

    this.blur();
    //First Shuffle: Extend Max Line
    if (shuffleCount === 0){

        //Extend Max Line
        cusumSvg.select("line")
      		.attr("x2",w*2)
          .attr("stroke-dasharray",[5,5])

        d3.select("#histoMX")
          .select("line")
          .style("opacity",1)
    };
    ////////////////////////


    data2 = d3.shuffle(data)
    generateRunningSum(data2)


    //Shuffle Line
    valueline = d3.line()
     .x(function(d,i){return xScale(i)})
     .y(d => yScale(d.value))

     d3.select("#RL").selectAll("path")
      .datum(data)
      .transition()
      .duration(800)
      .attr("d", valueline)
      .attr("class","line")
      .attr("stroke-dasharray",[8000,8000])

    //Shuffle Bars
    svg.selectAll("rect")
    .data(data2,d => d.key)
      .transition()
      .duration(800)
        .attr("x", function(d,i){return xScale(i)})

    //Shuffle Waterfall
    d3.select("#waterfallBars").selectAll("rect")
    	.data(rsData)
    	.transition()
    	.duration(1000)
    	.attr("x",function(d,i){return xScaleCUSUM(i)})
      .attr("y", d => yScaleCUSUM(Math.max(d.end, d.start)))
      .attr("height", d => h - yScaleCSMheight(Math.abs(d.end - d.start)))
    	.attr("fill", d => d.class === "positive"? "rgb(147,196,125)": "rgb(224,102,102)")

    //Adjust CUSUM rect
    d3.select("#cusumRect")
      .transition()
      .duration(1000)
      .attr("y",  yScaleCUSUM(rsMax))
      .attr("height", h - yScaleCUSUM(rsMax))

    //Update CUSUM Height Bars
    if (shuffleCount > 0) {

      //If fewer than 100 bars, scale to data length, else limit to 100
      xScaleCusumHeight.domain(d3.range(cusumHeightsDict.length < 50 ? cusumHeightsDict.length : 50).reverse())

      //If fewer than 100 values, take all values, else limit to last 100
  	  last100 = cusumHeightsDict.slice(cusumHeightsDict.length < 50 ? 0 : cusumHeightsDict.length-50 , cusumHeightsDict.length+1)

      cusumHeightBars = d3.select("#cusumHeightBars")
          .selectAll("rect")
          .data(last100, key = d => d.key)

  	  cusumHeightBars.enter()
  		  .append("rect")
  		  .attr("x",0)
  		  .attr("y",  yScaleCUSUM(cusumHeights[shuffleCount-1]))
  		  .attr("height", h - yScaleCUSUM(cusumHeights[shuffleCount-1]))
  		  .attr("width",w)
        .attr("class", cusumHeights[shuffleCount-1] > origHeight ? "over" : "under")
  		  .attr("opacity",0.5)
  			.merge(cusumHeightBars)
  			.transition()
  			.duration(500)
  			.attr("x",function(d,i){return xScaleCusumHeight(i)})
  			.attr("width",xScaleCusumHeight.bandwidth())
        .attr("opacity",1)

  	  cusumHeightBars.exit()
  		 .transition()
  		 .duration(1000)
  		 .attr("transform","translate("+w+",0)")
  		 .remove()

       hitRate = d3.sum(cusumHeights,d => d > origHeight ? 1 : 0) / shuffleCount * 100
       hitRate = hitRate.toFixed(1)+"%"
       hitRateNum.text(hitRate)

       //Update histogram
       let bins = histogram(cusumHeights)

       histoX.domain([0, d3.max(bins,function(d){return d.length;})])

       d3.select("#histoBars").selectAll("rect")
         .data(bins)
         .transition()
         .duration(1000)
           .attr("transform", function(d){return "translate(0, "+yScaleCUSUM(d.x1)+" )" })
           .attr("height",function(d){return yScaleCUSUM(d.x0) - yScaleCUSUM(d.x1); })
           .attr("width", function(d){return histoX(d.length);})

      simCountNum.text(shuffleCount)
    }

    if (shuffleCount == 5) {
      d3.select("#annCont").append("button").attr("class","btn btn-info").attr("id","autoShuffle").text("auto-shuffle ▶");
      shuffleInterval(dict,scales);
    }


  //Push latest CUSUM heights to dataset and increment the shuffleCount
   shuffleCount++

   cusumHeights.push(rsMax)
   cusumHeightsDict.push({"key":shuffleCount,"value":rsMax})

    })
  }

shuffleInterval = function(dict,scales){
  d3.select("#autoShuffle").on("click", function(){
    automate =! automate
    if (automate){
      inter = setInterval(function() {
        automateShuffle(dict,scales);
      }, 100);
      d3.select(this).text("pause ❚❚");
    } else {
      clearInterval(inter);
      d3.select(this).text("auto-shuffle ▶");
    }
  })
}

automateShuffle = function(data,scales){

    let {yScaleCUSUM} = scales;

    let duration = 100

    data2 = d3.shuffle(data)
    generateRunningSum(data2)
		shuffleCount ++
		cusumHeights.push(rsMax)
    cusumHeightsDict.push({"key":shuffleCount,"value":rsMax})

    //If fewer than 100 values, take all values, else limit to last 100
	  last100 = cusumHeightsDict.slice(cusumHeightsDict.length < 50 ? 0 : cusumHeightsDict.length-50 , cusumHeightsDict.length+1)

    //If fewer than 100 bars, scale to data length, else limit to 100
    xScaleCusumHeight.domain(d3.range(cusumHeightsDict.length < 50 ? cusumHeightsDict.length : 50).reverse())


      cusumHeightBars = d3.select("#cusumHeightBars")
          .selectAll("rect")
          .data(last100, key = d => d.key)


      cusumHeightBars.enter()
          .append("rect")
		      .attr("x",w - xScaleCusumHeight.bandwidth())
          .attr("y", d => yScaleCUSUM(d.value))
          .attr("height", d => h - yScaleCUSUM(d.value))
          .attr("opacity", 0)
          .attr("class", d => d.value > origHeight ? "over" : "under")
          .merge(cusumHeightBars)
          .transition()
          .duration(duration)
          .attr("x",function(d,i){return xScaleCusumHeight(i)})
          .attr("width",xScaleCusumHeight.bandwidth())
          .attr("opacity", 1)


	   cusumHeightBars.exit()
		 .transition()
		 .duration(duration)
		 .attr("transform","translate("+xScaleCusumHeight.bandwidth()+",0)")
		 .remove()

      let bins = histogram(cusumHeights)

      histoX.domain([0, d3.max(bins,function(d){return d.length;})])

      d3.select("#histoBars").selectAll("rect")
        .data(bins)
        .transition()
        .duration(duration)
          .attr("transform", function(d){return "translate(0, "+yScaleCUSUM(d.x1)+" )" })
          .attr("height",function(d){return yScaleCUSUM(d.x0) - yScaleCUSUM(d.x1); })
          .attr("width", function(d){return histoX(d.length);})
        //  .on("end",function(){automateShuffle(dict,scales)})

      simCountNum.text(shuffleCount)
      hitRate = d3.sum(cusumHeights,d => d > origHeight ? 1 : 0) / shuffleCount * 100
      hitRate = hitRate.toFixed(1)+"%"
      hitRateNum.text(hitRate)

}

showOrigTrend = function(data,scales){
  let {xScale,yScale,yScaleCUSUM,yScaleCSMheight,xScaleCUSUM} = scales;

  d3.select("#resetOrig").on("click",function(){
    data = dict.sort(function(a,b){return a.key - b.key})
    generateRunningSum(data)

    //Shuffle Line
    valueline = d3.line()
     .x(function(d,i){return xScale(i)})
     .y(d => yScale(d.value))

     d3.select("#RL").selectAll("path")
      .datum(data)
      .transition()
      .duration(1000)
      .attr("d", valueline)
      .attr("class","line")

    //Shuffle Bars
    svg.selectAll("rect")
    .data(data,d => d.key)
      .transition()
      .duration(1000)
        .attr("x", function(d,i){return xScale(i)})

    //Shuffle Waterfall
    d3.select("#waterfallBars").selectAll("rect")
      .data(rsData)
      .transition()
      .duration(1000)
      .attr("x",function(d,i){return xScaleCUSUM(i)})
      .attr("y", d => yScaleCUSUM(Math.max(d.end, d.start)))
      .attr("height", d => h - yScaleCSMheight(Math.abs(d.end - d.start)))
      .attr("fill", d => d.class === "positive"? "rgb(147,196,125)": "rgb(224,102,102)")

    //Adjust CUSUM rect
    d3.select("#cusumRect")
      .transition()
      .duration(1000)
      .attr("y",  yScaleCUSUM(rsMax))
      .attr("height", h - yScaleCUSUM(rsMax))
  })
}


showData = function(){
  dataGeneration();
  let scales = getScales(dict);
  drawLine(combinedArray,scales);
  cusumHeights = [];
  cusumHeightsDict = [];
  drawHisto(scales);
  showOrigTrend(dict,scales)
}
showData();


</script>

</html>
