<html>

<head>
    <style>
    /*CSS Styling*/
    .line {
    stroke-width: 1px;
    stroke: grey;
    fill: none
    }
    .mean {
    stroke-width: 1px;
    stroke: black;
    }
    .canvas {
    display:flex;
    flex-direction: column;
    }
    .subdiv {
    display:flex;
    flex-direction: row;
    }
    /*#topView {
    padding-bottom: 10px;
    }

    #line-chart{
    padding-top: 15px;
    padding-bottom: 15px;
    }*/

    #histo-container {
    margin-left: 10px;
    }

    </style>
<script src="https://d3js.org/d3.v4.min.js"></script>

<!-- Load bootstrap -->
<script src="http://code.jquery.com/jquery.js"></script>
<link href="./bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">
<script src="./bootstrap/js/bootstrap.min.js"></script>

</head>


<body>

<div class="btn-group" role="group" aria-label="Basic example">
	<button type="button" class="btn btn-info" id="Shuffle">Scramble Once</button>
	<button type="button" class="btn btn-primary" id="shuffleBatch" >Shuffle 100 times</button>
</div>
  <div class="button"><button id="showBars" type="button">Toggle Bars</button></div>
  <div id="mainView" class = "canvas">
      <div id="topView" class = "subdiv"></div>
      <div id="bottomView" class = "subdiv"></div>
  </div>
  </div>
</body>



<script>

w = 400
h = 250

let svg = d3.select("#topView").append("svg").attr("id","line-chart").attr("width",w).attr("height",h).style("border-radius", "6px").style("background-color", "#F7F8F9")
let cusumSvg = d3.select("#bottomView").append("svg").attr("width", w*2).attr("height", h).style("border-style", "solid").style("border-width", "2px").style("border-radius", "6px").style("background-color", "#f7ffff")
let histoSVG = d3.select("#bottomView").append("svg").attr("id","histo-container").attr("width",100).attr("height",h).style("border-style", "solid").style("border-width", "2px").style("background-color", "#2c3e50").style("border-radius", "6px")
let Button = d3.select("#Shuffle")
let ToggleBars = d3.select("#showBars")
let lineTrans = function(chart,duration,delay){
  let lineLength =  function(chart){return chart.node().getTotalLength();}
  chart.attr("stroke-dasharray",0+" "+lineLength(chart))
      .transition()
      .duration(duration)
      .delay(delay)
      .ease(d3.easeLinear)
      .attr("stroke-dasharray",lineLength(chart)+" "+lineLength(chart))
}
let showBars = true


dataGeneration = function(){

    randomArray = function(mean,stdev){
      let array = [];
      for(let i=0; i<30; i++){
        let newNumber = d3.randomNormal(mean,stdev)();
        array.push(newNumber);
      }
      return array
    }

    firstPhase = randomArray(20,5)
    secondPhase = randomArray(17,3)
    thirdPhase = randomArray(19,4)

    combinedArray = firstPhase.concat(secondPhase,thirdPhase)
    
    mean = d3.mean(combinedArray,d => d)

    dict = []
    combinedArray.map(function(d,i){
      dict[i] = {"key":i,"value":d}
    })
    

	generateRunningSum2 = function(data){
  	rsData = data.map((d,i) => promise = {"key":i, "value": d, "delta": d - mean})
	
  	    var cumulative = 0;
  	    for (var i = 0; i < data.length; i++) {
  	      rsData[i].start = cumulative;
  	      cumulative += rsData[i].delta;
  	      rsData[i].end = cumulative;
  	      rsData[i].class = ( rsData[i].delta >= 0 ) ? 'positive' : 'negative'
  	    }
	  }
	generateRunningSum2(combinedArray)

	rsMin = d3.min(rsData, d => Math.min(d.start,d.end))
	rsMax = d3.max(rsData, d => Math.max(d.start,d.end))
	rsHeight = rsMax - rsMin

    return {combinedArray,dict}
}

getScales = function(data){
	let xScale = d3.scaleBand()
		 .domain(d3.range(data.length))
		 .range([0,w]);

	let yScale = d3.scaleLinear()
		.domain([d3.min(rsData,(d => d.value)), d3.max(rsData,(d => d.value))])
		.range([h,0]);
		
	let yScaleCUSUM2 = d3.scaleLinear()
		.domain([rsMin,rsMax*1.6])
		.range([h,0]);

	let yScaleCUSUM3 = d3.scaleLinear()
		.domain([0, Math.abs(rsHeight)])
		.range([h,0]);
		
	let xScaleCUSUM = d3.scaleBand()
		.domain(d3.range(rsData.length))
		.range([0,w]);
		

  return {xScale,yScale, xScaleCUSUM, yScaleCUSUM2, yScaleCUSUM3}
}

drawLine = function(data,scales){
  let {xScale,yScale} = scales;

  svg.append("text")
    .attr("x",0)
    .attr("y",0)
    .text("Random Trend")
    .attr("fill","black")

   valueline = d3.line()
    .x(function(d,i){return xScale(i)})
    .y(d => yScale(d))


  let line = svg.append("g").attr("id","RL").append("path")
          .datum(data)
          .attr("d", valueline)
          .attr("class","line")
          lineTrans(line,4000,0)

  let meanLine = svg.append("g").append("line")
          .attr("x1",0)
	  .attr("x2",0)
	  .attr("y1",yScale(mean))	  
	  .attr("y2",yScale(mean))
	  .attr("stroke","black")
	  .transition().duration(1500).delay(4000)
	  .attr("x2",w).on("end",function(){animateWaterfall(rsData, scales)})
	  

}

toggleBars = function(){
  ToggleBars.on("click", function(){
    svg.selectAll("rect")
    .attr("fill-opacity", showBars ? 0 : 0.4)

    showBars =! showBars
})}

animateWaterfall = function(data, scales){
	let {xScale, yScale, yScaleCUSUM2, yScaleCUSUM3,xScaleCUSUM} = scales;

	
	rsData2 = []

	clickCount = 0
	
	inter = setInterval(function() {
                updateData();
		clickCount === rsData.length ? clearInterval(inter) : null
        }, 150); 

	updateData =  function(){
			rsData2[clickCount] = rsData[clickCount]
			
			clickCount ++
			
			yScaleCUSUM2.domain([d3.min(rsData2,d => Math.min(d.end, d.start)),d3.max(rsData2,d => d.end) <0 ? d3.max(rsData2,d => d.end) : d3.max(rsData2,d => d.end)*1.6])
			yScaleCUSUM3.domain([0, Math.abs(d3.min(rsData2,d => Math.min(d.end, d.start))) + (d3.max(rsData2,d => d.end) <0 ? 0 : d3.max(rsData2,d => d.end)*1.6)])

			
			waterfall = cusumSvg.selectAll("rect")
			      .data(rsData2)

			waterfallEnter = waterfall.enter()
			      .append("rect")
			      .attr("x",function(d,i){return xScaleCUSUM(i)})
			      .attr("y", d => yScaleCUSUM2(d.start))
			      .attr("height", 0)
			      .attr("width", xScaleCUSUM.bandwidth())
			      .attr("fill", d => d.class === "positive"? "green" : "red")
			      .attr('fill-opacity', 0.4)

			waterfall.merge(waterfallEnter)
				.transition()
				.attr("y", d => yScaleCUSUM2(Math.max(d.end, d.start)))
				.attr("height", d => h - yScaleCUSUM3(Math.abs(d.end - d.start)))
				
			bars = svg.selectAll("rect")
			       .data(rsData2, d =>  d.key)
			
			barsEnter = bars.enter()
			       .append("rect")
			       .attr("id",(d,i) => i)
			       .attr("x",function(d,i){return xScale(i)})
			       .attr("y", yScale(mean))
			       .attr("height",0)
			       .attr("width", xScale.bandwidth())
			       .attr("fill", d => d.class === "positive"? "green" : "red")
			       .attr('fill-opacity', 0.4)
			       .transition()
			       .attr("y", d => d.class === "positive" ? yScale(d.value) : yScale(mean))
			       .attr("height", d => Math.abs(yScale(mean) - yScale(d.value)))
		
		
		}
	
	
				shuffleCount = 0
}

cusumMax = function(scales){
	let {yScaleCUSUM2} = scales
	
	cusumSvg.append("line")
		.attr("x1",0)
		.attr("x2",0)
		.attr("y1",yScaleCUSUM2(rsMax))
		.attr("y2",yScaleCUSUM2(rsMax))
		.attr("stroke","black")
		.transition()
		.attr("x2",w)
}

drawHisto = function(){
  histoY = d3.scaleLinear()
    .domain([0,100])
    .range([h,0])

  histogram =  d3.histogram()
    .value(d => d)
    .domain(histoY.domain())
    .thresholds(histoY.ticks(40))

  bins = histogram(cusumHeights)

  histoX = d3.scaleLinear()
    .domain([0, d3.max(bins,function(d){return d.length;})])
    .range([0,100])

  histoSVG.selectAll("rect")
    .data(bins)
    .enter()
    .append("rect")
      .attr("x",0)
      .attr("y",0)
      .attr("transform", function(d){return "translate(0, "+histoY(d.x1)+" )" })
      .attr("height",function(d){return histoY(d.x0) - histoY(d.x1); })
      .attr("width", function(d){return histoX(d.length);})
      .style("fill", function(d){return (d.x0 + d.x1)/2  > rsHeight ? "#ccffff" : "black"})
      .attr("opacity",function(d){return (d.x0 + d.x1)/2  > rsHeight ? 0.4 : 0.2})

  histoSVG.append("g").attr("id","histoMX").append("line")
     .style("stroke","white")
     .attr("x1",0)
     .attr("x2",w)
     .attr("y1",histoY(rsHeight))
     .attr("y2",histoY(rsHeight))
     .attr("stroke-dasharray",[5,5])
     .style("opacity",0)

}



shuffleData = function(data,scales){
  Button.on("click", function(){
    let {xScale,yScale,yScaleCUSUM2,yScaleCUSUM3,xScaleCUSUM} = scales;
   

    //Original Line Chart Thumbnail
    if (shuffleCount === 0){

	originLineSvg = d3.select("#topView").append("svg").attr("width", 100).attr("height",60).style("border-radius", "6px").style("background-color", "#F7F8F9").style("margin-left","10px")

	      let shrunkenX = d3.scaleBand()
			     .domain(d3.range(combinedArray.length))
			     .range([0,100])


	      let shrunkenY = d3.scaleLinear()
			    .domain([d3.min(combinedArray), d3.max(combinedArray)])
			    .range([60,0])


	      shrunkenValueLine = d3.line()
	       .x(function(d,i){return shrunkenX(i)})
	       .y(d => shrunkenY(d))

	      originLineSvg.append("g").attr("id","OL").append("path")
		  .datum(combinedArray)
		  .attr("d", shrunkenValueLine)
		  .attr("class","line")
		  .style("stroke-width","0.5px")
    };

    shuffleCount++

    data2 = d3.shuffle(data)

    generateRunningSum3 = function(data){
  	rsData = data.map((d,i) => promise = {"key":i, "value": d.value, "delta": d.value - mean})
	
  	    var cumulative = 0;
  	    for (var i = 0; i < data.length; i++) {
  	      rsData[i].start = cumulative;
  	      cumulative += rsData[i].delta;
  	      rsData[i].end = cumulative;
  	      rsData[i].class = ( rsData[i].delta >= 0 ) ? 'positive' : 'negative'
  	    }
	    
	    
	   rsMin = d3.min(rsData, d => Math.min(d.start,d.end))
	   
	   for (var i=0; i < rsData.length; i++){
	    rsData[i].start = rsMin >= 0 ? rsData[i].start - rsMin : rsData[i].start + (rsMin*-1);
	    rsData[i].end = rsMin >= 0 ? rsData[i].end - rsMin :  rsData[i].end + (rsMin*-1);
	   }
	    

	    
	  }
    generateRunningSum3(data)


    yScaleCUSUM2.domain([0,rsHeight])
    yScaleCUSUM3.domain([0,rsHeight])

    //Shuffle Bars
    svg.selectAll("rect")
    .data(data2,d => d.key)
      .transition()
      .duration(1000)
        .attr("x", function(d,i){return xScale(i)})

    
    //Shuffle Line
    valueline = d3.line()
     .x(function(d,i){return xScale(i)})
     .y(d => yScale(d.value))
     
    d3.select("#RL").selectAll("path")
      .datum(data)
      .transition()
      .duration(1000)
      .attr("d", valueline)
      .attr("class","line")
      .attr("stroke-dasharray",[8000,8000])
      
    //Shuffle Waterfall
    cusumSvg.selectAll("rect")
	.data(rsData)
	.transition()
	.duration(1000)
	.attr("x",function(d,i){return xScaleCUSUM(i)})
        .attr("y", d => yScaleCUSUM2(Math.max(d.end, d.start)))
        .attr("height", d => h - yScaleCUSUM3(Math.abs(d.end - d.start)))
	.attr("fill", d => d.class === "positive"? "green" : "red")
    
			  
    //Update Histogram

    d3.select("#histoMX")
      .select("line")
      .style("opacity",1)

    let bins = histogram(cusumHeights)

    histoX.domain([0, d3.max(bins,function(d){return d.length;})])

    histoSVG.selectAll("rect")
      .data(bins)
      .transition()
      .duration(1000)
        .attr("transform", function(d){return "translate(0, "+histoY(d.x1)+" )" })
        .attr("height",function(d){return histoY(d.x0) - histoY(d.x1); })
        .attr("width", function(d){return histoX(d.length);})

  //Push latest CUSUM heights to dataset
   cusumHeights.push(rsHeight)


    })
  }

shuffleBatch = function(data){
    d3.select("#shuffleBatch").on("click", function(){
      for(var i=0; i<100; i++){
        data = d3.shuffle(data)
        let values = data.map(d => d.value)
        generateRunningSum(values)
        cusumHeights.push(rsHeight)
      }


      xScaleCusumHeight.domain(d3.range(cusumHeights.length))
      //
      cusumHeightBars = d3.select("#cusumHeightBars")
          .selectAll("rect")
          .data(cusumHeights)

      cusumHeightBars.enter()
          .append("rect")
          .attr("x",w)
          .attr("y", d => yScaleCUSUM(d))
          .attr("height", d => h- yScaleCUSUM(d))
          .attr("opacity",d => d > rsHeight ? 0.4 : 0.2)
          .merge(cusumHeightBars)
          .transition()
          .duration(500)
          .attr("x",function(d,i){return xScaleCusumHeight(i)})
          .attr("width",xScaleCusumHeight.bandwidth())

      let bins = histogram(cusumHeights)

      histoX.domain([0, d3.max(bins,function(d){return d.length;})])

      histoSVG.selectAll("rect")
        .data(bins)
        .transition()
        .duration(1000)
          .attr("transform", function(d){return "translate(0, "+histoY(d.x1)+" )" })
          .attr("height",function(d){return histoY(d.x0) - histoY(d.x1); })
          .attr("width", function(d){return histoX(d.length);})
        ///  .attr("opacity",function(d){return (d.x0 + d.x1)/2  > rsHeight} ? 0.5 : 0.1)

    })
  }



showData = function(){
  dataGeneration();
  let scales = getScales(dict);
  drawLine(combinedArray,scales);
  cusumHeights = [];
  toggleBars();
  //animateWaterfall(rsData, scales);
  //cusumMax(scales);
  drawHisto();
  shuffleData(dict,scales);
  shuffleBatch(dict);
}
showData();


</script>

</html>