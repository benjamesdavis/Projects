<html>

<head>
    <style>
    /*CSS Styling*/
    .line {
    stroke-width: 1px;
    stroke: grey;
    fill: none
    }
    .mean {
    stroke-width: 1px;
    stroke: black;
    }
    .canvas {
    display:flex;
    flex-direction: column;
    }
    .subdiv {
    display:flex;
    flex-direction: row;
    }
    /*#topView {
    padding-bottom: 10px;
    }

    #line-chart{
    padding-top: 15px;
    padding-bottom: 15px;
    }*/

    #histo-container {
    margin-left: 10px;
    }

    </style>
<script src="https://d3js.org/d3.v4.min.js"></script>

<!-- Load bootstrap -->
<script src="http://code.jquery.com/jquery.js"></script>
<link href="../bootstrap-4.4.1-dist/css/bootstrap.min.css" rel="stylesheet" media="screen">
<script src="../bootstrap-4.4.1-dist/js/bootstrap.min.js"></script>

</head>


<body>

<div class="btn-group" role="group" aria-label="Basic example">
	<button type="button" class="btn btn-info" id="Shuffle">Scramble Once</button>
	<button type="button" class="btn btn-primary" id="shuffleBatch" >Shuffle 100 times</button>
</div>
  <div class="button"><button id="showBars" type="button">Toggle Bars</button></div>
  <div id="mainView" class = "canvas">
      <div id="topView" class = "subdiv"></div>
      <div id="bottomView" class = "subdiv"></div>
  </div>
  </div>
</body>



<script>

w = 400
h = 250

let svg = d3.select("#topView").append("svg").attr("id","line-chart").attr("width",w).attr("height",h).style("border-radius", "6px").style("background-color", "#F7F8F9")
let cusumSvg = d3.select("#bottomView").append("svg").attr("width", w*2).attr("height", h).style("border-style", "solid").style("border-width", "2px").style("border-radius", "6px").style("background-color", "#f7ffff")
let histoSVG = d3.select("#bottomView").append("svg").attr("id","histo-container").attr("width",100).attr("height",h).style("border-style", "solid").style("border-width", "2px").style("background-color", "#2c3e50").style("border-radius", "6px")
let Button = d3.select("#Shuffle")
let ToggleBars = d3.select("#showBars")
let lineTrans = function(chart,duration,delay){
  let lineLength =  function(chart){return chart.node().getTotalLength();}
  chart.attr("stroke-dasharray",0+" "+lineLength(chart))
      .transition()
      .duration(duration)
      .delay(delay)
      .ease(d3.easeLinear)
      .attr("stroke-dasharray",lineLength(chart)+" "+lineLength(chart))
}
let showBars = true


dataGeneration = function(){

    randomArray = function(mean,stdev){
      let array = [];
      for(let i=0; i<30; i++){
        let newNumber = d3.randomNormal(mean,stdev)();
        array.push(newNumber);
      }
      return array
    }

    firstPhase = randomArray(20,5)
    secondPhase = randomArray(17,3)
    thirdPhase = randomArray(19,4)

    combinedArray = firstPhase.concat(secondPhase,thirdPhase)

    mean = d3.mean(combinedArray,d => d)

    dict = []
    combinedArray.map(function(d,i){
      dict[i] = {"key":i,"value":d}
    })


  generateRunningSum = function(data){
  	rsData = data.map((d,i) => promise = {"key":i, "value": d.value, "delta": d.value - mean})

  	    var cumulative = 0;
  	    for (var i = 0; i < data.length; i++) {
  	      rsData[i].start = cumulative;
  	      cumulative += rsData[i].delta;
  	      rsData[i].end = cumulative;
  	      rsData[i].class = ( rsData[i].delta >= 0 ) ? 'positive' : 'negative'
  	    }

      rsMin = d3.min(rsData, d => Math.min(d.start,d.end))

      for (var i=0; i < rsData.length; i++){
 	    rsData[i].start = rsMin >= 0 ? rsData[i].start - rsMin : rsData[i].start + (rsMin*-1);
 	    rsData[i].end = rsMin >= 0 ? rsData[i].end - rsMin :  rsData[i].end + (rsMin*-1);
 	   }
      rsMax = d3.max(rsData, d => Math.max(d.start,d.end))
	  }
  generateRunningSum(dict)

  return {combinedArray,dict}
}

getScales = function(data){
	let xScale = d3.scaleBand()
		 .domain(d3.range(data.length))
		 .range([0,w]);

	let yScale = d3.scaleLinear()
		.domain([d3.min(rsData,(d => d.value)), d3.max(rsData,(d => d.value))])
		.range([h,0]);

	let yScaleCUSUM = d3.scaleLinear()
		.domain([0,rsMax*1.6])
		.range([h,0]);

	let yScaleCSMheight = d3.scaleLinear()
		.domain([0, Math.abs(rsMax)])
		.range([h,0]);

	let xScaleCUSUM = d3.scaleBand()
		.domain(d3.range(rsData.length))
		.range([0,w]);


  return {xScale,yScale, xScaleCUSUM, yScaleCUSUM, yScaleCSMheight}
}

drawLine = function(data,scales){
  let {xScale,yScale} = scales;

  svg.append("text")
    .attr("x",0)
    .attr("y",0)
    .text("Random Trend")
    .attr("fill","black")

   valueline = d3.line()
    .x(function(d,i){return xScale(i)})
    .y(d => yScale(d))


  let line = svg.append("g").attr("id","RL").append("path")
          .datum(data)
          .attr("d", valueline)
          .attr("class","line")
          lineTrans(line,4000,0)

  let meanLine = svg.append("g").append("line")
          .attr("x1",0)
	  .attr("x2",0)
	  .attr("y1",yScale(mean))
	  .attr("y2",yScale(mean))
	  .attr("stroke","black")
	  .transition().duration(1500).delay(4000)
	  .attr("x2",w).on("end",function(){animateWaterfall(rsData, scales)})


}

toggleBars = function(){
  ToggleBars.on("click", function(){
    svg.selectAll("rect")
    .attr("fill-opacity", showBars ? 0 : 0.4)

    showBars =! showBars
})}


animateWaterfall = function(data, scales){
	let {xScale, yScale, yScaleCUSUM, yScaleCSMheight,xScaleCUSUM} = scales;

	rsData2 = []

	clickCount = 0

  //Draw CUSUM rect behind waterfall
  cusumSvg.append("rect").attr("id","cusumRect")
    .attr("x",0)
    .attr("y", yScaleCUSUM(rsMax))
    .attr("width",w)
    .attr("height", h - yScaleCUSUM(rsMax))
    .attr("fill", "grey")
    .attr("opacity", 0)

  //Cycle through updateData until all data points are rendered
	inter = setInterval(function() {
    addDelta();
    //clickCount > 3 ?  clearInterval(inter) : null
    clickCount === rsData.length ?  clearInterval(inter) : null
    clickCount === rsData.length ? cusumMax(scales) : null
        }, 150);

  waterfallGroup = cusumSvg.append("g").attr("id","waterfallBars")

	addDelta =  function(){
			rsData2[clickCount] = rsData[clickCount]

			clickCount ++

      yScaleCUSUM.domain([d3.min(rsData2,d => Math.min(d.end, d.start)) , d3.max(rsData2,d => Math.max(d.end, d.start)) * 1.6])
      yScaleCSMheight.domain([0 , (d3.max(rsData2,d => Math.max(d.end, d.start))*1.6) - d3.min(rsData2,d => Math.min(d.end, d.start))])

			waterfall = d3.select("#waterfallBars").selectAll("rect")
			      .data(rsData2)

			waterfallEnter = waterfall.enter()
			      .append("rect")
			      .attr("x",function(d,i){return xScaleCUSUM(i)})
			      .attr("y", d => yScaleCUSUM(d.start))
			      .attr("height", 0)
			      .attr("width", xScaleCUSUM.bandwidth())
			      .attr("fill", d => d.class === "positive"? d3.rgb("#94C895"): d3.rgb("#FA9595")) //#94C895 = green | #FA9595 = red
			      .attr('fill-opacity', 1)

			waterfall.merge(waterfallEnter)
				.transition()
				.attr("y", d => yScaleCUSUM(Math.max(d.end, d.start)))
				.attr("height", d => h - yScaleCSMheight(Math.abs(d.end - d.start)))

			bars = svg.selectAll("rect")
			       .data(rsData2, d =>  d.key)

			barsEnter = bars.enter()
			       .append("rect")
			       .attr("id",(d,i) => i)
			       .attr("x",function(d,i){return xScale(i)})
			       .attr("y", yScale(mean))
			       .attr("height",0)
			       .attr("width", xScale.bandwidth())
			       .attr("fill", d => d.class === "positive"? "green" : "red")
			       .attr('fill-opacity', 0.4)
			       .transition()
			       .attr("y", d => d.class === "positive" ? yScale(d.value) : yScale(mean))
			       .attr("height", d => Math.abs(yScale(mean) - yScale(d.value)))

		}


				shuffleCount = 0

}

cusumMax = function(scales){
	let {yScaleCUSUM} = scales

  origHeight = rsMax
  origHeight2 = rsMax - rsMin

	cusumSvg.append("line")
		.attr("x1",0)
		.attr("x2",0)
		.attr("y1",yScaleCUSUM(rsMax))
		.attr("y2",yScaleCUSUM(rsMax))
		.attr("stroke","black")
		.transition()
    .duration(1500)
		.attr("x2",w)

  cusumSvg.select("#cusumRect")
    .transition()
    .duration(4000)
    .delay(500)
    .attr("opacity",0.25)

  xScaleCusumHeightInit = d3.scaleBand()
                      .domain(d3.range(100).reverse())
                      .range([0,w])


  xScaleCusumHeight = d3.scaleBand()
                      .domain(d3.range(cusumHeights.length))
                      .range([w,w*2])


  cusumSvg.append("g").attr("id","cusumHeightBars")
}

drawHisto = function(scales){
  let {yScaleCUSUM} = scales;

  histogram =  d3.histogram()
    .value(d => d)
    .domain(yScaleCUSUM.domain())
    .thresholds(yScaleCUSUM.ticks(40))

  bins = histogram(cusumHeights)

  histoX = d3.scaleLinear()
    .domain([0, d3.max(bins,function(d){return d.length;})])
    .range([0,100])

  histoSVG.selectAll("rect")
    .data(bins)
    .enter()
    .append("rect")
      .attr("x",0)
      .attr("y",0)
      .attr("transform", function(d){return "translate(0, "+yScaleCUSUM(d.x1)+" )" })
      .attr("height",function(d){return yScaleCUSUM(d.x0) - yScaleCUSUM(d.x1); })
      .attr("width", function(d){return histoX(d.length);})
      .style("fill", function(d){return (d.x0 + d.x1)/2  > rsMax ? "#ccffff" : "black"})
      .attr("opacity",function(d){return (d.x0 + d.x1)/2  > rsMax ? 0.4 : 0.2})

  histoSVG.append("g").attr("id","histoMX").append("line")
     .style("stroke","white")
     .attr("x1",0)
     .attr("x2",w)
     .attr("y1",yScaleCUSUM(rsMax))
     .attr("y2",yScaleCUSUM(rsMax))
     .attr("stroke-dasharray",[5,5])
     .style("opacity",0)

}



shuffleData = function(data,scales){
  Button.on("click", function(){
    let {xScale,yScale,yScaleCUSUM,yScaleCSMheight,xScaleCUSUM} = scales;


    //First Shuffle: Original Line Chart Thumbnail + Extend Max Line
    if (shuffleCount === 0){

	     originLineSvg = d3.select("#topView")
          .append("svg")
          .attr("width", 100)
          .attr("height",60)
          .style("border-radius", "6px")
          .style("background-color", "#F7F8F9")
          .style("margin-left","10px")

	      let shrunkenX = d3.scaleBand()
			     .domain(d3.range(combinedArray.length))
			     .range([0,100])

	      let shrunkenY = d3.scaleLinear()
			    .domain([d3.min(combinedArray), d3.max(combinedArray)])
			    .range([60,0])

	      shrunkenValueLine = d3.line()
	       .x(function(d,i){return shrunkenX(i)})
	       .y(d => shrunkenY(d))

  	    originLineSvg.append("g").attr("id","OL").append("path")
  		  .datum(combinedArray)
  		  .attr("d", shrunkenValueLine)
  		  .attr("class","line")
  		  .style("stroke-width","0.5px")

        //Extend Max Line
        cusumSvg.select("line")
      		.attr("x2",w*2)
          .attr("stroke-dasharray",[5,5])

        d3.select("#histoMX")
          .select("line")
          .style("opacity",1)
    };
    ////////////////////////


    data2 = d3.shuffle(data)
    generateRunningSum(data)


    //Shuffle Line
    valueline = d3.line()
     .x(function(d,i){return xScale(i)})
     .y(d => yScale(d.value))

     d3.select("#RL").selectAll("path")
      .datum(data)
      .transition()
      .duration(1000)
      .attr("d", valueline)
      .attr("class","line")
      .attr("stroke-dasharray",[8000,8000])

    //Shuffle Bars
    svg.selectAll("rect")
    .data(data2,d => d.key)
      .transition()
      .duration(1000)
        .attr("x", function(d,i){return xScale(i)})

    //Shuffle Waterfall
    d3.select("#waterfallBars").selectAll("rect")
    	.data(rsData)
    	.transition()
    	.duration(1000)
    	.attr("x",function(d,i){return xScaleCUSUM(i)})
      .attr("y", d => yScaleCUSUM(Math.max(d.end, d.start)))
      .attr("height", d => h - yScaleCSMheight(Math.abs(d.end - d.start)))
    	.attr("fill", d => d.class === "positive"? d3.rgb("#94C895"): d3.rgb("#FA9595"))

    //Adjust CUSUM rect
    d3.select("#cusumRect")
      .transition()
      .duration(1000)
      .attr("y",  yScaleCUSUM(rsMax))
      .attr("height", h - yScaleCUSUM(rsMax))

    //Update CUSUM Height Bars
    if (shuffleCount > 0) {

      //If fewer than 100 bars, scale to data length, else limit to 100
      xScaleCusumHeight.domain(d3.range(cusumHeightsDict.length < 100 ? cusumHeightsDict.length : 100).reverse())
      xScaleCusumHeight.padding(0.1)

      //If fewer than 100 values, take all values, else limit to last 100
  	  last100 = cusumHeightsDict.slice(cusumHeightsDict.length < 100 ? 0 : cusumHeightsDict.length-100 , cusumHeightsDict.length+1)

      cusumHeightBars = d3.select("#cusumHeightBars")
          .selectAll("rect")
          .data(last100, key = d => d.key)

  	  cusumHeightBars.enter()
  		  .append("rect")
  		  .attr("x",0)
  		  .attr("y",  yScaleCUSUM(cusumHeights[shuffleCount-1]))
  		  .attr("height", h - yScaleCUSUM(cusumHeights[shuffleCount-1]))
  		  .attr("width",w)
  		  .attr("opacity",d => d.value > origHeight ? 0.4 : 0.2)
  			.merge(cusumHeightBars)
  			.transition()
  			.duration(500)
  			.attr("x",function(d,i){return xScaleCusumHeight(i)})
  			.attr("width",xScaleCusumHeight.bandwidth())

  	  cusumHeightBars.exit()
  		 .transition()
  		 .duration(1000)
  		 .attr("transform","translate("+w+",0)")
  		 .remove()
    }


    //Update histogram
    let bins = histogram(cusumHeights)

    histoX.domain([0, d3.max(bins,function(d){return d.length;})])

    histoSVG.selectAll("rect")
      .data(bins)
      .transition()
      .duration(1000)
        .attr("transform", function(d){return "translate(0, "+yScaleCUSUM(d.x1)+" )" })
        .attr("height",function(d){return yScaleCUSUM(d.x0) - yScaleCUSUM(d.x1); })
        .attr("width", function(d){return histoX(d.length);})


  //Push latest CUSUM heights to dataset and increment the shuffleCount
   shuffleCount++

   cusumHeights.push(rsMax)
   cusumHeightsDict.push({"key":shuffleCount,"value":rsMax})

    })
  }

shuffleBatch = function(data, scales){
    let {yScaleCUSUM, xScaleCUSUM} = scales;
    //Generate 100 more CUSUM Height values
    d3.select("#shuffleBatch").on("click", function(){

    barsToFill = cusumHeights.length < 100 ? 100-cusumHeights.length : 100

      for(var i=0; i<barsToFill; i++){
        data = d3.shuffle(data)
        generateRunningSum(data)
    		shuffleCount ++
    		cusumHeights.push(rsMax)
        cusumHeightsDict.push({"key":shuffleCount,"value":rsMax})
      }


	  //Take last 100 values
	  last100 = cusumHeightsDict.slice(cusumHeightsDict.length - 100 ,cusumHeightsDict.length+1)

      xScaleCusumHeight.domain(d3.range(100).reverse()) //Re-calibrate x-axis to accommodate new values


      cusumHeightBars = d3.select("#cusumHeightBars")
          .selectAll("rect")
          .data(last100, key = d => d.key)


      cusumHeightBars.enter()
          .append("rect")
          .attr("x",function(d,i){return xScaleCusumHeightInit(i)})
		  //.attr("x",w)
          .attr("y", d => yScaleCUSUM(d.value))
          .attr("height", d => h - yScaleCUSUM(d.value))
          .attr("opacity", d => d.value > origHeight ? 0.4 : 0.2)
          .merge(cusumHeightBars)
          .transition()
          .duration(1000)
          .attr("x",function(d,i){return xScaleCusumHeight(i)})
          .attr("width",xScaleCusumHeight.bandwidth())


	   cusumHeightBars.exit()
		 .transition()
		 .duration(1000)
		 .attr("transform","translate("+w+",0)")
		 .remove()

      let bins = histogram(cusumHeights)

      histoX.domain([0, d3.max(bins,function(d){return d.length;})])

      histoSVG.selectAll("rect")
        .data(bins)
        .transition()
        .duration(1000)
          .attr("transform", function(d){return "translate(0, "+yScaleCUSUM(d.x1)+" )" })
          .attr("height",function(d){return yScaleCUSUM(d.x0) - yScaleCUSUM(d.x1); })
          .attr("width", function(d){return histoX(d.length);})


    })
  }



showData = function(){
  dataGeneration();
  let scales = getScales(dict);
  drawLine(combinedArray,scales);
  cusumHeights = [];
  cusumHeightsDict = [];
  toggleBars();
  drawHisto(scales);
  shuffleData(dict,scales);
  shuffleBatch(dict,scales);
}
showData();


</script>

</html>
